# Шпаргалка по Python SQLite: Базовая информация

## Что такое СУБД и реляционные БД?

**База данных** — это хранилище структурированной информации.

**Реляционные базы данных** — базы, в которых данные представлены в видесвязанных таблиц.

**СУБД (система управления базами данных)** — это комплекс программ, который позволяет создать базу данных, наполнить её новыми таблицами, отобразить содержимое, редактировать существующие таблицы.

**Таблица** — это совокупность строк и столбцов.

**Поле** — столбец таблицы с характеристикой объекта, уникальным именем и характерным типом данных.

**Запись** — строка таблицы, содержащая информацию об одном объекте.

**Ячейка** — место пересечения строки и столбца.

**Первичный ключ** — поле или группа полей, использующиеся для однозначного определения записи. Все значения первичного ключа уникальны.

**SQL (Structured Query Language)** — это язык для работы с данными в реляционных базах данных. Он позволяет создавать, изменять и управлять данными, а также получать доступ к информации, хранящейся в таблицах базы данных.

**Запрос** — это сформулированное в соответствии с синтаксисом SQL требование, в котором объявляют, какие данные выбрать, и как именно их обработать.

**API (Application Programming Interface)** — это набор правил и инструментов, который позволяет программам взаимодействовать между собой. Он определяет, как одна программа может запросить данные или вызвать функции в другой.

**API и Базы Данных** <br>

**Связь с БД:** `API` может выполнять запросы к базе данных от лица клиента. Например, когда приложение запрашивает информацию о пользователе, `API` отправляет запрос к базе данных, обрабатывает данные и возвращает ответ клиенту.

**Роль API:** Он выполняет роль "посередине" между базой данных и пользователями, обеспечивая безопасный доступ к данным, а также может выполнять бизнес-логику.

**Взаимодействие с СУБД:** `API` управляет доступом к СУБД. Когда пользователь хочет получить данные, `API` формирует `SQL`-запросы, выполняет их в базе данных и возвращает данные клиенту в удобном формате (например, `JSON`).

## Популярные СУБД для Python

1. `SQLite`

    **Описание:** Легковесная встраиваемая СУБД, не требует отдельного сервера.

    **Использование:** Встраивается в приложения, подходит для разработки прототипов, мобильных приложений и небольших проектов.

    **Подключение в Python:** sqlite3 (встроенный модуль).

    **Плюсы:** Простота, встроенность в Python, не требует настроек.

    **Минусы:** Ограниченные функции для работы с большими объемами данных.

    https://sqlitebrowser.org/

2. `MySQL`

    **Описание:** Серверная СУБД, популярная в веб-разработке.

    **Использование:** Широко используется для крупных веб-приложений, электронной коммерции, социальных сетей.

    **Подключение в Python:** Через библиотеки `mysql-connector-python`, `PyMySQL` или `SQLAlchemy` (ORM).

    **Плюсы:** Высокая производительность, поддержка сложных запросов.

    **Минусы:** Сложность настроек, ограниченная поддержка расширенных типов данных.

3. `PostgreSQL`

    **Описание:** Мощная, расширяемая СУБД с поддержкой сложных типов данных.

    **Использование:** Используется для аналитических систем, финансовых приложений, крупных проектов с интенсивной нагрузкой.

    **Подключение в Python:** `psycopg2`, `asyncpg` (асинхронный доступ), или `SQLAlchemy`.

    **Плюсы:** Поддержка `JSON`, массивов, сложных запросов, транзакций и расширений (например, для геоданных).

    **Минусы:** Требует больше ресурсов для обслуживания.

4. `MongoDB`

    **Описание:** Документо-ориентированная `NoSQL` СУБД, хранит данные в формате `JSON`-подобных документов.

    **Использование:** Подходит для приложений, работающих с неструктурированными или динамически изменяемыми данными (например, интернет-магазины).

    **Подключение в Python:** `pymongo`.

    **Плюсы:** Гибкость схемы, масштабируемость.

    **Минусы:** Не поддерживает транзакции в полном объеме, может потребовать больше места для хранения данных.

5. `Redis`

    **Описание:** СУБД в оперативной памяти (in-memory), используется как кеш, база данных или брокер сообщений.

    **Использование:** Часто используется для кэширования данных, брокеров сообщений, создания очередей задач.

    **Подключение в Python:** `redis-py`.

    **Плюсы:** Высокая скорость, поддержка структур данных (списки, множества, хеши).

    **Минусы:** Ограничена размером оперативной памяти, данные могут быть потеряны при сбое (если не включена запись на диск).

6. `Cassandra`

    **Описание:** Распределенная СУБД для работы с большими объемами данных и поддержкой масштабируемости.

    **Использование:** Подходит для приложений с большим количеством записей (например, логи, мониторинг).

    **Подключение в Python:** `cassandra-driver`.

    **Плюсы:** Высокая отказоустойчивость, масштабируемость.

    **Минусы:** Требует сложной настройки, не поддерживает традиционные реляционные отношения.

7. `MariaDB`

    **Описание:** Форк `MySQL`, создан для повышения производительности и отказоустойчивости.

    **Использование:** Альтернатива `MySQL`, активно используется в веб-приложениях и аналитике.

    **Подключение в Python:** `mysql-connector-python`, `PyMySQL`.

    **Плюсы:** Совместимость с `MySQL`, высокая производительность.

    **Минусы:** Ограниченная поддержка некоторых сложных функций `PostgreSQL`.

8. `Oracle Database`

    **Описание:** Мощная корпоративная СУБД, поддерживающая масштабируемые и безопасные транзакционные системы.

    **Использование:** Применяется в финансовом и государственном секторе, где важны надежность и безопасность.

    **Подключение в Python:** `cx_Oracle`.

    **Плюсы:** Высокая безопасность, поддержка распределенных баз данных.

    **Минусы:** Платная лицензия, сложность настроек.

9. `Microsoft SQL Server`

    **Описание:** СУБД от Microsoft, популярная в корпоративной среде.

    **Использование:** Корпоративные приложения, аналитика, взаимодействие с другими продуктами Microsoft.

    **Подключение в Python:** `pyodbc`, `pymssql`.

    **Плюсы:** Интеграция с экосистемой Microsoft, высокая производительность.

    **Минусы:** Преимущественно платная, сложная настройка.

## Рекомендации для выбора СУБД
Для разработки и прототипов: `SQLite`. <br>
Для веб-приложений с большими нагрузками: `MySQL`, `PostgreSQL`.<br>
Для аналитики и сложных данных: `PostgreSQL`.<br>
Для работы с документами и `NoSQL`: `MongoDB`.<br>
Для кэширования и очередей задач: `Redis`.<br>
Для распределенных систем с большой нагрузкой: `Cassandra`.<br>

## Подключение к БД

**Импорт модуля `sqlite3`**

Для работы с `SQLite` в Python необходимо импортировать модуль `sqlite3`. Это стандартный модуль, входящий в состав Python.
```python
import sqlite3
```
Можно задать для модуля синоним, чтобы упростить запись:
```python
import sqlite3 as sq
```

**Метод `connect()`**

Метод `connect()` используется для установки соединения с базой данных.

```python
con = sqlite3.connect('имя_файла.db')
```

`con` в методе `connect` — это просто имя переменной, в которой сохраняется объект соединения с базой данных. Это может быть любое имя, но обычно используют сокращения вроде `con` (от "connection") или `conn` для ясности кода.


Другими словами, мы создаем объект соединения, который управляет доступом к базе данных. Этот объект `con` позволяет нам взаимодействовать с базой через курсор `cursor` и выполнять запросы `execute`, а также управлять транзакциями (например, `commit`, `rollback`).



`имя_файла.db` — имя файла базы данных SQLite.

- Если указанный файл базы данных уже существует, `connect()` просто подключится к этой базе.

- Если база данных отсутствует, `connect()` создаст новый файл с указанным именем и расширением `.db`.

- Файл базы данных SQLite представляет собой файл `.db`, но допустимы и другие расширения, такие как `.db3`, `.sqlite` или `.sqlite3`.

- Если указан только имя файла, он будет создан в текущей директории.

- Если указан полный путь к файлу (например, `/path/to/database.db`), база будет создана по этому пути.

**Метод `close()`**

Метод `close()` используется для закрытия соединения с базой данных.

```python
con.close()
```
- Закрытие соединения освобождает ресурсы.

- Важно всегда закрывать соединение, когда оно больше не нужно, чтобы предотвратить утечку памяти и другие проблемы.

**Метод `cursor()`**

Метод `cursor()` создает объект-курсор, с помощью которого можно выполнять SQL-запросы.

- Курсор — это объект, который управляет и выполняет SQL-запросы.

- Он позволяет отправлять SQL-команды в базу данных и управлять результатами запросов.

**Метод `execute()`**

Метод `execute()` используется для выполнения SQL-запросов.

```python
cur.execute('SQL-команда', параметры)
```

- SQL-команда — строка с запросом SQL, который нужно выполнить (например, создание таблицы, добавление данных и т.д.).

- параметры — не обязательны, но их можно использовать для подстановки значений в запрос.

- Этот метод позволяет выполнять различные SQL-запросы, такие как создание таблиц, вставка данных, выборка данных и т. д.

```python
cur.execute('CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY, name TEXT)')
cur.execute('INSERT INTO users (name) VALUES (?)', ('Alice',))
```

**Контекстный менеджер `with`**

Использование конструкции `with` для работы с SQLite упрощает код и делает его более безопасным:

- Автоматическое закрытие соединения: Контекстный менеджер автоматически закрывает соединение, когда блок кода завершается. Это предотвращает утечки памяти.

- Обработка ошибок: Если внутри блока with происходит ошибка, Python гарантирует, что соединение с базой данных все равно будет закрыто корректно.

```python
with sqlite3.connect('test.db') as con:
    cur = con.cursor()
    cur.execute('SQL-команда')
    # любые другие SQL-запросы
# соединение закрывается автоматически
```

Пример использования `with`:
```python
import sqlite3

# Подключение к базе данных с помощью контекстного менеджера `with`
with sqlite3.connect('test.db') as con:
    cur = con.cursor()
    cur.execute('CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY, name TEXT)')
    cur.execute('INSERT INTO users (name) VALUES (?)', ('Alice',))
    cur.execute('SELECT * FROM users')

    # Вывод данных
    for row in cur.fetchall():
        print(row)
# По завершении блока `with` соединение закрывается автоматически
```

Хотя `with` упрощает работу, его можно не использовать. Однако, в этом случае нужно самостоятельно закрывать соединение с помощью `close()`.

Аналогичный пример, без использования `with`:

```python
import sqlite3

# Подключение к базе данных
con = sqlite3.connect('test.db')
cur = con.cursor()

# SQL-команды
cur.execute('CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY, name TEXT)')
cur.execute('INSERT INTO users (name) VALUES (?)', ('Alice',))
cur.execute('SELECT * FROM users')

# Вывод данных
for row in cur.fetchall():
    print(row)

# Закрытие соединения вручную
con.close()
```
**Важно: Без `with` есть риск забыть закрыть соединение, что может привести к утечке ресурсов!**

## Типы данных в таблице SQLite, форматы и их особенности

SQLite поддерживает несколько типов данных, которые можно использовать при создании таблиц. Вот основные из них:

Тип данных | Описание
-----------|------------
`INTEGER`    | Целые числа, могут использоваться для ID и счетчиков.
`REAL`       | Числа с плавающей точкой, для хранения дробных чисел.
`TEXT`       | Текстовые строки, такие как имена или описания.
`BLOB`       | Данные, которые не будут интерпретироваться SQLite, например, изображения или бинарные файлы.
`NULL`       | Представляет отсутствующее значение.

SQLite использует динамическую типизацию. Это значит, что значения в одной колонке могут быть разного типа, даже если тип был определен при создании таблицы. Например, можно сохранить строку в колонке `INTEGER`, хотя это не рекомендуется.

## Принятые правила написания кода на языке SQL

Для повышения читаемости и удобства работы с кодом рекомендуется соблюдать следующие правила:

- Ключевые слова SQL (например, `SELECT`, `FROM`, `WHERE`, `CREATE`, `INSERT`) пишутся заглавными буквами. Это помогает быстро отличить команды SQL от других элементов кода.

- Названия таблиц и столбцов пишутся строчными буквами, но могут быть разделены подчеркиванием (например, `user_name`, `order_date`).

- Отступы: Рекомендуется использовать 4 пробела для каждого уровня отступа. Это помогает структурировать запросы и делает их более читаемыми.

- Запросы разделяются на несколько строк, если они слишком длинные, чтобы улучшить читаемость.

- Используйте `--` для однострочных комментариев в SQL коде.

- Ограничители (`PRIMARY KEY`, `NOT NULL`, `DEFAULT`) пишутся после типа данных для более четкой структуры.

```SQL
-- Это однострочный комментарий
SELECT user_name, user_email
FROM users
WHERE user_age > 21
ORDER BY user_name;
```

## Создание и удаление таблиц

Создание таблицы в SQLite выполняется с помощью команды `CREATE TABLE`. Основной синтаксис выглядит так:

```sql
CREATE TABLE [IF NOT EXISTS] table_name (
    column1 datatype [CONSTRAINTS],
    column2 datatype [CONSTRAINTS],
    ...
);

-- В квадратные скобки заключены необязательные части синтаксиса, которые можно включать или пропускать.
```

Пример команды для создания таблицы с несколькими типами данных и ограничениями:

```python
cur.execute('''CREATE TABLE IF NOT EXISTS users (
    user_id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    sex INTEGER NOT NULL DEFAULT 1,
    old INTEGER,
    score INTEGER
)''')
```

- `PRIMARY KEY`: Указывает, что столбец будет уникальным идентификатором записи. Он помогает избежать дублирования и позволяет быстро находить определенные записи. В каждой таблице можно задать только один `PRIMARY KEY`, также, он не может быть пустым `NULL`.

    Cуществуют другие типы ключей, например:

    - `UNIQUE` — обеспечивает уникальность значений в столбце, но позволяет иметь несколько NULL значений.

    - `FOREIGN KEY` — связывает одну таблицу с другой. Используется для установления ссылок между таблицами.

- `AUTOINCREMENT`: используется для автоматического увеличения значения столбца с типом `INTEGER PRIMARY KEY` на единицу для каждой новой записи.
    - Например, если первая запись получает user_id = 1, следующая запись получит user_id = 2, и так далее.
    - Увеличение всегда происходит на +1, обеспечивая непрерывную нумерацию записей, что удобно для уникальной идентификации.

    Важно: В SQLite `AUTOINCREMENT` не обязателен — без него база данных также увеличивает значение, если столбец имеет тип `INTEGER PRIMARY KEY`. Однако `AUTOINCREMENT` гарантирует, что значения не будут повторяться даже после удаления записей.

- `NOT NULL`: Указывает, что столбец не может содержать NULL (пустое) значение.
- `DEFAULT`: Указывает значение по умолчанию, если при вставке записи не указано значение для этого столбца.
- `CHECK`: Проверяет соответствие значению условию, например, возраст больше нуля (age > 0).
- `IF NOT EXISTS` — создаст таблицу только если ее нет.
- Если таблица уже существует и нужно пересоздать, нужно предварительно выполнить команду удаления.

Чтобы удалить таблицу, используется команда `DROP TABLE`:

```python
cur.execute('DROP TABLE IF EXISTS users')
```

- `DROP TABLE` — команда для удаления таблицы.
- `IF EXISTS` — условие, которое предотвращает ошибку, если таблица не существует.

Пример кода для удаления таблицы и работы с другими командами:

```python
import sqlite3

# Создаем соединение с базой данных
con = sqlite3.connect('test.db')
cur = con.cursor()

# Удаляем таблицу, если она существует
cur.execute('DROP TABLE IF EXISTS users')

# Создаем новую таблицу
cur.execute('''CREATE TABLE IF NOT EXISTS users (
    user_id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    sex INTEGER NOT NULL DEFAULT 1,
    old INTEGER,
    score INTEGER
)''')

# Добавляем запись
cur.execute('''INSERT INTO users (name, sex, old, score)
               VALUES (?, ?, ?, ?)''', ('Bob', 2, 25, 90))

# Сохраняем изменения
con.commit()

# Закрываем соединение
con.close()
```

## Команды `SELECT` и `INSERT` при работе с таблицами БД

**Команда `INSERT`**

Команда `INSERT` используется в SQL для добавления новых данных в таблицу. Она позволяет вставить одну или несколько строк в таблицу базы данных.

```sql
INSERT INTO table_name (column1, column2, ...)
VALUES (value1, value2, ...);
```

- table_name — имя таблицы, в которую вы хотите вставить данные.
- column1, column2, ... — имена столбцов таблицы, в которые вы хотите вставить данные.
- value1, value2, ... — значения для этих столбцов.

Допустим, у нас есть таблица users с полями: id, name, age и email.

```sql
CREATE TABLE users (
    id INTEGER PRIMARY KEY,
    name TEXT NOT NULL,
    age INTEGER,
    email TEXT
);
```

Чтобы добавить нового пользователя в эту таблицу, мы используем команду `INSERT`:

```sql
INSERT INTO users (name, age, email)
VALUES ('Alice', 25, 'alice@example.com');
```

Этот запрос добавит строку в таблицу `users`, где:

- `name` = 'Alice'
- `age` = 25
- `email` = 'alice@example.com'

Теперь рассмотрим, как выполнить команду `INSERT` из программы на `Python`, используя модуль `sqlite3`.

```python
import sqlite3

# Подключаемся к базе данных (или создаем, если не существует)
con = sqlite3.connect('test.db')
cur = con.cursor()

# Создаем таблицу (если она не существует)
cur.execute('''
CREATE TABLE IF NOT EXISTS users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    age INTEGER,
    email TEXT
)
''')

# Добавляем данные в таблицу
cur.execute('''
INSERT INTO users (name, age, email)
VALUES (?, ?, ?)
''', ('Bob', 30, 'bob@example.com'))

# Сохраняем изменения в базе данных
con.commit()

# Закрываем соединение
con.close()
```

**Особенности команды `INSERT`:**

- Автоматическое увеличение `id` с помощью `AUTOINCREMENT`:

    Если в таблице есть столбец, который является первичным ключом (например, `id`) и имеет атрибут `AUTOINCREMENT`, его значение будет автоматически увеличиваться с каждым новым добавлением строки.
    Это полезно, чтобы не указывать вручную значения для уникальных идентификаторов.

- Множественные вставки:

    Если нужно вставить несколько строк за один запрос, можно использовать несколько значений в команде `INSERT`:

    ```sql
    INSERT INTO users (name, age, email)
    VALUES ('Charlie', 28, 'charlie@example.com'),
       ('David', 22, 'david@example.com'),
       ('Eva', 35, 'eva@example.com');
    ```

    В Python это будет выглядеть так:

    ```python
    cur.executemany('''
    INSERT INTO users (name, age, email)
    VALUES (?, ?, ?)
    ''', [
    ('Charlie', 28, 'charlie@example.com'),
    ('David', 22, 'david@example.com'),
    ('Eva', 35, 'eva@example.com')
    ])
    ```

- Использование плейсхолдеров `?`:

    В запросах `INSERT` рекомендуется использовать плейсхолдеры (знак `?`), чтобы избежать SQL-инъекций и упростить вставку данных. Вместо того чтобы напрямую вставлять данные в запрос, плейсхолдеры позволяют передавать значения в запрос безопасным способом.

    ```python
    # Подключение к базе данных
    import sqlite3
    conn = sqlite3.connect('example.db')
    cursor = conn.cursor()

    # Данные, которые мы хотим вставить
    name = "John Doe"
    age = 30
    email = "johndoe@example.com"

    # Запрос с плейсхолдерами
    cursor.execute("INSERT INTO users (name, age, email) VALUES (?, ?, ?)", (name, age, email))

    # Сохранение изменений и закрытие соединения
    conn.commit()
    conn.close()
    ```

    - `INSERT INTO users (name, age, email)` — указываем, что будем вставлять данные в столбцы `name`, `age` и `email` таблицы `users`.
    - `VALUES (?, ?, ?)` — плейсхолдеры `?`, которые будут заменены на реальные значения: "John Doe", 30 и "johndoe@example.com".
    - Плейсхолдеры безопасны, так как они предотвращают SQL-инъекции, так как значения автоматически экранируются перед выполнением запроса.

    SQL-инъекция — это тип атаки, когда злоумышленник вводит в запрос вредоносный код. Если передавать в запрос данные напрямую, такие как `cur.execute(f"SELECT * FROM users WHERE name='{username}'")`, то злоумышленник может ввести код, нарушающий безопасность.
    ```python
    username = "'; DROP TABLE users; --"
    cur.execute(f"SELECT * FROM users WHERE name='{username}'")
    ```
    Если передать такое значение в запрос, это может привести к удалению таблицы `users`.

- Когда не указывается столбец:

    Если не указываем имена столбцов в запросе `INSERT`, предполагается, что вы вставляем данные во все столбцы таблицы, в том порядке, в котором они были определены. Однако, это не рекомендуется, так как это может привести к ошибкам, если структура таблицы изменится.

    ```sql
    INSERT INTO users VALUES (NULL, 'Alice', 25, 'alice@example.com');
    ```

    В данном случае значение `NULL` будет автоматически присвоено первичному ключу `id`, если он настроен как `AUTOINCREMENT`.


**Команда `SELECT`**

`SELECT` используется для извлечения данных из таблицы.

```sql
SELECT столбец1, столбец2, ... FROM имя_таблицы;
```
Чтобы выбрать все столбцы, используйте `*`:

```sql
SELECT * FROM имя_таблицы;
```
Условие `WHERE` задаёт фильтр для строк.

```sql
SELECT * FROM users WHERE score > 80;
```

**Операторы сравнения:**

`=`— равно

`>` / `<` — больше / меньше

`>=` / `<=` — больше или равно / меньше или равно

`!=` или `<>` — не равно

`LIKE` — осуществляет поиск по шаблону:

- `_` заменяет один символ

 - `%` заменяет любое количество символов


```sql
SELECT * FROM users WHERE name LIKE 'A%'; -- Все имена, начинающиеся с 'A'
```

```sql
SELECT * FROM users WHERE name LIKE 'A__a'; -- Ищет всех пользователей, у которых имя начинается на 'A', заканчивается на 'a' и содержит ровно два символа между ними.
```

`BETWEEN` проверяет, попадает ли значение в указанный диапазон (включительно).

```sql
SELECT * FROM users WHERE old BETWEEN 20 AND 30;
```
**Составные условия:**

Используются ключевые слова:

- `AND` — логическое "И". Оба условия должны быть выполнены.
- `OR` — логическое "ИЛИ". Достаточно выполнения одного из условий.
- `NOT` — логическое "НЕ". Инвертирует условие.


```sql
SELECT * FROM users
WHERE score > 80 AND old < 30;
```

**Приоритет операций:**

Когда используются запросы с несколькими условиями, важно понимать, в каком порядке они будут выполняться. В SQLite существует установленный порядок выполнения операций, который похож на математический.

Вот список операторов в порядке приоритета (от самого высокого к самому низкому):

- Скобки `()`.
Всегда выполняются первыми. Если нужно изменить порядок выполнения операций, используются скобки.
Пример:

```sql
SELECT * FROM users WHERE (age > 18 AND score > 50) OR sex = 1;
-- Сначала проверяются возраст и баллы, потом условие пола.
```

- Операторы сравнения.
Например: `=`, `>`, `<`, `>=`, `<=`, `!=` (или `<>`). Эти операторы определяют соответствие между значениями.

```sql
SELECT * FROM users WHERE age > 18;
-- Выбирает всех пользователей старше 18 лет.
```


- Операторы `NOT`.
Выполняются после сравнения, но перед `AND` и `OR`. Используются для инверсии логического выражения.

```sql
SELECT * FROM users WHERE NOT sex = 1;
-- Выбирает всех пользователей, чей пол НЕ равен 1.
```

- Операторы `AND`. Выполняются после `NOT`. Используются для соединения двух условий, оба из которых должны быть истинными.

```sql
SELECT * FROM users WHERE age > 18 AND score > 50;
-- Выбирает пользователей старше 18 с баллами больше 50.
```

- Операторы `OR`. Выполняются последними. Используются для соединения двух условий, хотя бы одно из которых должно быть истинным.

```sql
SELECT * FROM users WHERE age > 18 OR score > 50;
-- Выбирает пользователей старше 18 ИЛИ с баллами больше 50.
```

Пример приоритезации:

```sql
SELECT * FROM users WHERE age > 18 AND score > 50 OR sex = 1;
-- Условие разбивается так:
-- 1. Проверяется возраст (age > 18) и баллы (score > 50) для первой части условия.
-- 2. Потом проверяется пол (sex = 1).
-- 3. В итоге выбираются пользователи, которые (старше 18 И имеют баллы больше 50) ИЛИ чей пол равен 1.
```

Если нужно явно задать порядок выполнения, используются скобки:

```sql
SELECT * FROM users WHERE age > 18 AND (score > 50 OR sex = 1);
-- Теперь сначала выполняется условие (score > 50 OR sex = 1), а затем результат сравнивается с возрастом.
```

Если запрос кажется сложным, лучше использовать скобки для повышения читаемости и точности выполнения.
Логические операторы выполняются строго по приоритету, поэтому добавление скобок минимизирует риск ошибки в логике запроса.

**Сортировка с `ORDER BY`**

`ORDER BY` — это команда SQL, которая используется для сортировки данных в таблице. Она помогает упорядочить результаты запроса по одному или нескольким столбцам, как в порядке возрастания, так и убывания.

```sql
SELECT столбцы
FROM таблица
ORDER BY столбец_1 [ASC | DESC], столбец_2 [ASC | DESC], ...;
```

- `ORDER BY` — ключевое слово для сортировки данных.
- столбец_1, столбец_2 — столбцы, по которым будет выполняться сортировка.
- `ASC` (по умолчанию) — сортировка по возрастанию (от меньшего к большему).
- `DESC` — сортировка по убыванию (от большего к меньшему).

Сортировка начинается с первого указанного столбца.

Если в первом столбце есть одинаковые значения, сортировка продолжается по следующему столбцу, который указан.


```sql
SELECT name, age, score
FROM users
ORDER BY age;
-- Сортирует пользователей по возрасту в порядке возрастания.
```

```sql
SELECT name, age, score
FROM users
ORDER BY score DESC;
-- Сортирует пользователей по баллам в порядке убывания.
```

```sql
SELECT name, age, score
FROM users
ORDER BY age ASC, score DESC;
-- Сначала сортирует по возрасту в порядке возрастания.
-- Если возраст совпадает, сортирует по баллам в порядке убывания.
```

```sql
SELECT name, age
FROM users
ORDER BY name;
-- Сортирует пользователей по имени в алфавитном порядке (A-Z).
```

```sql
SELECT name, age, score
FROM users
ORDER BY score DESC, name ASC;
-- Сортирует по баллам в порядке убывания.
-- Если баллы совпадают, сортирует по именам в алфавитном порядке.
```

**Особенности использования `ORDER BY`:**

- Сортировка по индексу столбца.

    Вместо имени столбца можно указать номер столбца в запросе:

    ```sql
    SELECT name, age, score
    FROM users
    ORDER BY 2 ASC;
    -- Сортирует по 2-му столбцу (age) в порядке возрастания.
    ⚠️ Но лучше использовать имена столбцов, так как номера столбцов делают запросы менее читаемыми.
    ```

- Сортировка по выражениям.

    Можно использовать выражения в `ORDER BY`:

    ```sql
    SELECT name, age, score
    FROM users
    ORDER BY age + score DESC;
    -- Сортирует по сумме возраста и баллов в порядке убывания.
    ```

- `NULL` в сортировке.

    В `SQLite`, `NULL` значения при сортировке:

    - В ASC (возрастающем) порядке располагаются первыми.
    - В DESC (убывающем) порядке располагаются последними.

```sql
SELECT name, age
FROM users
ORDER BY age ASC;
-- Если у кого-то нет возраста (NULL), эти строки будут первыми.
```

- Ключевые слова для точного контроля `NULL`.

    Можно явно управлять расположением `NULL` значений:

    ```sql
    SELECT name, age
    FROM users
    ORDER BY age ASC NULLS LAST;
    -- NULL значения будут располагаться в конце.
    ```

Рекомендации:
- Писать явные направления сортировки (ASC или DESC), даже если они кажутся очевидными. Это делает код более читаемым.
- Избегать использования номеров столбцов в ORDER BY. Имена столбцов лучше читаются и устойчивы к изменениям структуры таблицы.
- Проверять порядок с реальными данными. В случае сомнений добавить запрос `LIMIT` для отображения нескольких первых строк:
    ```sql
    SELECT name, age, score
    FROM users
    ORDER BY score DESC
    LIMIT 5;
    -- Выведет 5 строк с наибольшим количеством баллов.
    ```

**Ограничение результатов с `LIMIT` и `OFFSET`**

`LIMIT` — это команда SQL, которая используется для ограничения количества строк, возвращаемых запросом. Это полезно, когда нужно получить только часть данных, например, первые 10 записей.

```sql
SELECT столбцы
FROM таблица
LIMIT количество;
```

`LIMIT количество` — определяет, сколько строк будет возвращено.

```sql
SELECT name, age
FROM users
LIMIT 5;
-- Вернет первые 5 строк из таблицы `users`.
```

`OFFSET` позволяет пропустить определенное количество строк перед тем, как начать возвращать результаты. Это часто используется совместно с `LIMIT`, чтобы разбить данные на "страницы".

```sql
SELECT столбцы
FROM таблица
LIMIT количество OFFSET смещение;
```

`OFFSET смещение` — количество строк, которые нужно пропустить перед началом выборки.

```sql
SELECT name, age
FROM users
LIMIT 5 OFFSET 10;
-- Пропустит первые 10 строк и вернет следующие 5 строк.
```

Примеры использования:

```sql
SELECT name, age
FROM users
LIMIT 3;
-- Вернет первые 3 строки.
```

Постраничный вывод:

```sql
SELECT name, age
FROM users
LIMIT 5 OFFSET 0;
-- Первая страница: первые 5 строк.
```

```sql
SELECT name, age
FROM users
LIMIT 5 OFFSET 5;
-- Вторая страница: пропустит первые 5 строк, вернет следующие
```

```sql
SELECT name, age
FROM users
LIMIT 5 OFFSET 10;
-- Третья страница: пропустит первые 10 строк, вернет следующие 5.
```


Как работают `LIMIT` и `OFFSET` вместе?

Представим, что у нас есть таблица с данными:

ID	| Name | Age
----|------|----
1 | Alice | 25
2 | Bob | 30
3 | Charlie | 22
4 | David | 28
5 | Eva | 35
6 | Frank | 40
7 | Grace | 29

```sql
SELECT name, age
FROM users
LIMIT 3 OFFSET 3;
```

Результат:

Name | Age
-----|-----
David | 28
Eva | 35
Frank | 40

- LIMIT 3 — выбирает только 3 строки.
- OFFSET 3 — пропускает первые 3 строки.


Сначала применяется OFFSET, чтобы пропустить указанное количество строк.

Затем применяется LIMIT, чтобы выбрать нужное количество строк.

**Рекомендации:**

- `OFFSET` без `LIMIT` тоже работает, но в большинстве случаев они используются вместе:

    ```sql
    SELECT name, age
    FROM users
    OFFSET 5;
    -- Пропустит первые 5 строк, вернет остальные.
    ```

- Лучше сортировать данные перед использованием `LIMIT` и `OFFSET`, чтобы избежать случайного порядка строк:

    ```sql
    SELECT name, age
    FROM users
    ORDER BY age ASC
    LIMIT 5 OFFSET 5;
    -- Получите отсортированные данные.
    ```

- Разделение данных на страницы (`pagination`) — основное применение `LIMIT` и `OFFSET`. Например, если у вас есть 1000 записей, вы можете показывать по 10 записей на странице:

    - Страница 1: `LIMIT` 10 `OFFSET` 0
    - Страница 2: `LIMIT` 10 `OFFSET` 10
    - Страница 3: `LIMIT` 10 `OFFSET` 20

- Сложность больших `OFFSET` значений

    Если таблица большая, использование больших значений для `OFFSET` может быть медленным, так как СУБД все равно должна пройти первые строки, чтобы их пропустить. В таких случаях лучше использовать условия `WHERE` с идентификаторами записей.


### Метод `fetchmany(size)`

`fetchmany(size)` — это метод объекта курсора (`cursor`), который позволяет получить фиксированное количество строк из результатов выполнения запроса.
Если нужно читать данные частями (например, по `5`, `10` или `100` строк), этот метод идеально подходит.

Зачем использовать `fetchmany(size)`?
Удобно, при работе с большими таблицами, где загрузка всех строк сразу может занять много памяти.
Позволяет эффективно обрабатывать данные по частям.

```python
cursor.fetchmany(size)
```
`size` — количество строк, которое нужно получить из результатов запроса.

- Если в результате запроса осталось больше строк, чем указано в `size`, метод вернет ровно столько строк, сколько указано.
- Если строк меньше, чем `size`, метод вернет оставшиеся строки.
- Если строк больше не осталось, метод вернет пустой список `[]`.

Допустим, у нас есть таблица `users` с данными:

ID | Name | Age
---|------|----
1 | Alice | 25
2 | Bob | 30
3 | Charlie | 22
4 | David | 28
5 | Eva | 35

```python
import sqlite3

# Подключение к БД
con = sqlite3.connect("test.db")
cur = con.cursor()

# Выбираем все строки из таблицы
cur.execute("SELECT * FROM users")

# Получаем первые 2 строки
rows = cur.fetchmany(2)
print("Первая порция данных:", rows)

# Получаем следующие 2 строки
rows = cur.fetchmany(2)
print("Вторая порция данных:", rows)

# Получаем оставшиеся строки
rows = cur.fetchmany(2)
print("Последняя порция данных:", rows)

# Закрываем соединение
con.close()
```
Результат выполнения:

```less
Первая порция данных: [(1, 'Alice', 25), (2, 'Bob', 30)]
Вторая порция данных: [(3, 'Charlie', 22), (4, 'David', 28)]
Последняя порция данных: [(5, 'Eva', 35)]
```
Пример использования:
```python
cur.execute("SELECT * FROM users")
rows = cur.fetchmany(10)  # Просим 10 строк, но в таблице только 5
print(rows)
```
Результат:

```css
[(1, 'Alice', 25), (2, 'Bob', 30), (3, 'Charlie', 22), (4, 'David', 28), (5, 'Eva', 35)]
```

Метод `fetchmany(size)` удобно использовать в цикле, чтобы динамически получать данные небольшими порциями.

```python
cur.execute("SELECT * FROM users")

while True:
    rows = cur.fetchmany(2)  # Читаем по 2 строки
    if not rows:
        break  # Если строк больше нет, выходим из цикла
    print(rows)
```
Результат:

```css
[(1, 'Alice', 25), (2, 'Bob', 30)]
[(3, 'Charlie', 22), (4, 'David', 28)]
[(5, 'Eva', 35)]
```

Когда использовать `fetchmany(size)` вместо `fetchall()`?
- `fetchall()` загружает все строки сразу в память. Подходит для небольших объемов данных.
- `fetchmany(size)` — работает более эффективно с большими объемами данных, читая их порциями.


Рекомендации:
- Если таблица небольшая (до 1000 строк), можно использовать `fetchall()` для простоты.
- При работе с большими таблицами всегда выбирать `fetchmany(size)` или итерацию через курсор (`for row in cur:`).
- Размер `size` выбирать исходя из возможностей памяти устройства и объема данных.

### Метод `fetchone()`

Метод `fetchone()` — это метод объекта курсора (`cursor`), который позволяет получить одну строку из результатов выполнения запроса.
Если в результате запроса есть хотя бы одна строка, метод вернет первую строку, а если строк нет — вернет `None`.

Зачем использовать `fetchone()`?
- Когда нужно извлечь только одну строку. Например, если запрос вернет уникальный результат (например, при поиске пользователя по имени или ID).
- Экономит память, потому что не загружает все данные сразу, а только одну строку.

```python
cursor.fetchone()
```

Допустим, у нас есть таблица `users` с такими данными:

ID | Name | Age
---|------|----
1 | Alice | 25
2 | Bob | 30
3 | Charlie | 22
4 | David | 28
5 | Eva | 35

Теперь, рассмотрим пример с использованием `fetchone()`:

python
Копировать код

```python
import sqlite3

# Подключаемся к базе данных
con = sqlite3.connect("test.db")
cur = con.cursor()

# Выполняем запрос
cur.execute("SELECT * FROM users WHERE age > 30")

# Получаем одну строку (первую)
row = cur.fetchone()
print(row)

# Закрываем соединение
con.close()
```
Результат:
```css
(5, 'Eva', 35)
```

Здесь мы ищем пользователей старше 30 лет. Поскольку в базе данных только одна такая запись (Eva), метод `fetchone()` вернул эту строку.

Если нет строк, которые соответствуют запросу (например, если никто не старше 40 лет), метод вернет `None`:

```python
cur.execute("SELECT * FROM users WHERE age > 40")
row = cur.fetchone()
print(row)  # Выведет None, так как таких пользователей нет
```
```css
None
```

Когда полезно использовать?

Использовать `fetchone()`, когда уверены, что запрос должен вернуть только одну строку или когда нужно обрабатывать результат по одной строке за раз.
Например, когда ищем пользователя по уникальному идентификатору или логину.

Если нужно обрабатывать данные по одной строке за раз, можно использовать цикл и вызывать `fetchone()` в нем:

```python
cur.execute("SELECT * FROM users")

# Читаем и обрабатываем данные по одной строке
while True:
    row = cur.fetchone()
    if row is None:
        break  # Выход из цикла, если данных больше нет
    print(row)
```
```arduino
(1, 'Alice', 25)
(2, 'Bob', 30)
(3, 'Charlie', 22)
(4, 'David', 28)
(5, 'Eva', 35)
```
Этот подход полезен для обработки больших данных по частям, чтобы не загружать все строки сразу в память.