# Шпаргалка по Python: Базовая информация

## Комментарии

Комментарии помогают сделать код понятнее и лучше структурированным. Они игнорируются интерпретатором и предназначены только для разработчиков.

**Однострочные комментарии** <br>

Однострочные комментарии начинаются с символа #. Всё, что написано после #, будет проигнорировано. <br>

Пример: <br>

```python
# Это комментарий, поясняющий следующий код
x = 10  # Присваиваем переменной x значение 10
```
**Рекомендации**:

* Использовать однострочные комментарии, чтобы кратко описать, что делает та или иная строка кода.

* Можно использовать комментарии в конце строки, но стараться не злоупотреблять этим, чтобы код не выглядел перегруженным.

**Многострочные комментарии**

Для многострочных комментариев можно использовать несколько строк с # перед каждой из них.

Пример:

```python
# Этот код выполняет следующие задачи:
# 1. Присваивает переменной x значение 10
# 2. Присваивает переменной y значение 20
# 3. Выводит сумму x и y
x = 10
y = 20
print(x + y)
```
**Рекомендации**:

* Многострочные комментарии полезны для описания алгоритмов или блоков кода.

* Делать многострочные комментарии короткими и по делу, не перегружать их ненужной информацией.

* Чтобы добавить многострочные комментарии с помощью горячих клавиш, можно использовать комбинации `Ctrl + /` (Windows/Linux) или `Cmd + /` (MacOS).

**Докстринги (docstrings)**

Докстринги — это специальные строки для документирования функций, классов или модулей. Они заключаются в тройные кавычки ''' ( либо """ ) и могут быть как однострочными, так и многострочными.

Пример:

```python
def add(a, b):
    """Возвращает сумму двух чисел."""
    return a + b
```

Многострочные докстринги:

```python
def multiply(a, b):
    """
    Возвращает произведение двух чисел.

    Параметры:
    a (int): Первое число
    b (int): Второе число

    Возвращает:
    int: Произведение a и b
    """
    return a * b
```

**Рекомендации:**

* Использовать докстринги для описания назначения функций, их параметров и возвращаемых значений.

* Для многострочных докстрингов придерживаться стандартных стилей оформления, как в примере.

**Зачем писать комментарии?**

* Улучшение читаемости кода: Комментарии помогают другим разработчикам (и самому в будущем) быстрее понять код.

* Пояснение сложных частей: Если в коде есть сложные алгоритмы, краткие пояснения помогут избежать недопонимания.

* Документация проекта: Хорошо комментированный код можно легко использовать как документацию для проекта.

**Когда НЕ нужно писать комментарии?**

* Не комментировать очевидные вещи: комментарии вроде `# Присваиваем x значение 10` для строки `x = 10` — излишни.

* Не объяснять синтаксис языка — это подразумевается по умолчанию.
<br><br>

# Операции и специальные символы в Python

**Арифметические операторы**

| Символ            | Описание                                                                                                                              | Пример использования                 | Типы данных                          |
|-------------------|----------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------|--------------------------------------|
| `+`               | Сложение двух чисел или конкатенация строк.                                                                                            | `2 + 3  # 5`                         | `int`, `float`, `str`                |
| `-`               | Вычитание одного числа из другого.                                                                                                     | `5 - 2  # 3`                         | `int`, `float`                       |
| `*`               | Умножение двух чисел или повторение строки.                                                                                            | `4 * 2  # 8`, `"a" * 3  # "aaa"`     | `int`, `float`, `str` (умножение на число) |
| `/`               | Деление двух чисел, результат — дробное число.                                                                                         | `7 / 2  # 3.5`                       | `int`, `float`                       |
| `//`              | Целочисленное деление, результат — целое число без остатка.                                                                             | `7 // 2  # 3`                        | `int`, `float`                       |
| `%`               | Остаток от деления (модуль). Показывает, что остается после деления.                                                                    | `7 % 2  # 1`                         | `int`, `float`                       |
| `**`              | Возведение числа в степень.                                                                                                            | `2 ** 3  # 8`                        | `int`, `float`                       |

<br>

**Операторы сравнения**

| Символ            | Описание                                                                                                                              | Пример использования                 | Типы данных                          |
|-------------------|----------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------|--------------------------------------|
| `==`              | Проверка, равны ли два значения. Возвращает `True` или `False`.                                                                        | `5 == 5  # True`                     | Все типы данных                      |
| `!=`              | Проверка, не равны ли два значения.                                                                                                    | `5 != 3  # True`                     | Все типы данных                      |
| `>`               | Проверка, больше ли первое значение второго.                                                                                           | `5 > 3  # True`                      | `int`, `float`, `str` (по алфавиту)  |
| `<`               | Проверка, меньше ли первое значение второго.                                                                                           | `2 < 5  # True`                      | `int`, `float`, `str` (по алфавиту)  |
| `>=`              | Проверка, больше или равно ли первое значение второму.                                                                                 | `5 >= 5  # True`                     | `int`, `float`, `str` (по алфавиту)  |
| `<=`              | Проверка, меньше или равно ли первое значение второму.                                                                                 | `3 <= 4  # True`                     | `int`, `float`, `str` (по алфавиту)  |

<br>

**Логические операторы**

| Символ            | Описание                                                                                                                              | Пример использования                 | Типы данных                          |
|-------------------|----------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------|--------------------------------------|
| `and`             | Возвращает `True`, если оба выражения истинны.                                                                                         | `True and False  # False`            | `bool`                               |
| `or`              | Возвращает `True`, если хотя бы одно выражение истинно.                                                                                | `True or False  # True`              | `bool`                               |
| `not`             | Возвращает противоположное значение (инвертирует).                                                                                     | `not True  # False`                  | `bool`                               |


<br>

**Операторы для работы со словарями**

| Символ            | Описание                                                                                                                              | Пример использования                 | Типы данных                          |
|-------------------|----------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------|--------------------------------------|
| `in`              | Проверка, есть ли ключ в словаре или элемент в последовательности.                                                                    | `"a" in my_dict  # True`             | `dict`, `list`, `str`, `set`         |
| `not in`          | Проверка отсутствия ключа в словаре или элемента в последовательности.                                                                 | `"x" not in my_dict  # True`         | `dict`, `list`, `str`, `set`         |

<br>

**Операторы присваивания**

| Символ            | Описание                                                                                                                              | Пример использования                 | Типы данных                          |
|-------------------|----------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------|--------------------------------------|
| `=`               | Присваивает значение переменной.                                                                                                       | `x = 5`                              | Все типы данных                      |
| `+=`              | Увеличивает значение переменной на указанное число.                                                                                     | `x += 3  # x = x + 3`                | `int`, `float`, `str`, `list`        |
| `-=`              | Уменьшает значение переменной на указанное число.                                                                                       | `x -= 2  # x = x - 2`                | `int`, `float`                       |
| `*=`              | Умножает значение переменной на указанное число.                                                                                        | `x *= 2  # x = x * 2`                | `int`, `float`, `str`, `list`        |
| `/=`              | Делит значение переменной на указанное число.                                                                                           | `x /= 2  # x = x / 2`                | `int`, `float`                       |

<br>

**Операторы последовательностей**

| Символ            | Описание                                                                                                                              | Пример использования                 | Типы данных                          |
|-------------------|----------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------|--------------------------------------|
| `[]`              | Доступ к элементам списка или строки по индексу (номеру позиции).                                                                      | `my_list[0]  # 1`                    | `list`, `tuple`, `str`               |
| `[:]`             | Создание среза — получение подсписка или части строки.                                                                                 | `my_list[1:3]  # [2, 3]`             | `list`, `tuple`, `str`               |
| `+`               | Объединение строк или списков.                                                                                                         | `"Hello, " + "world!"  # "Hello, world!"` | `str`, `list`, `tuple`           |
| `*`               | Повторяет строку или список указанное количество раз.                                                                                  | `[1, 2] * 3  # [1, 2, 1, 2, 1, 2]`   | `str`, `list`, `tuple`               |

<br>

**Операторы множеств**

| Символ            | Описание                                                                                                                              | Пример использования                 | Типы данных                          |
|-------------------|----------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------|--------------------------------------|
| `\|`               | Объединение двух множеств (все уникальные элементы).                                                                                   | `set1 \| set2  # {1, 2, 3, 4, 5}`       | `set`, `frozenset`                   |
| `&`               | Пересечение множеств (общие элементы).                                                                                                | `set1 & set2  # {3}`                 | `set`, `frozenset`                   |
| `-`               | Разность множеств (все элементы первого множества, которых нет во втором).                                                             | `set1 - set2  # {1, 2}`              | `set`, `frozenset`                   |
| `^`               | Симметрическая разность (все элементы, которые есть только в одном из множеств).                                                       | `set1 ^ set2  # {1, 2, 4, 5}`        | `set`, `frozenset`                   |

<br>

**Побитовые операторы**

| Символ            | Описание                                                                                                                              | Пример использования                 | Типы данных                          |
|-------------------|----------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------|--------------------------------------|
| `&`               | Побитовое И (логическое И для каждого бита чисел).                                                                                     | `5 & 3  # 1`                         | `int`                                |
| `\|`               | Побитовое ИЛИ (логическое ИЛИ для каждого бита чисел).                                                                                 | `5 \| 3  # 7`                          | `int`                                |
| `^`               | Побитовое исключающее ИЛИ (возвращает `1`, если биты отличаются).                                                                      | `5 ^ 3  # 6`                         | `int`                                |
| `~`               | Побитовое НЕ (инверсия битов).                                                                                                        | `~5  # -6`                           | `int`                                |
| `<<`              | Сдвиг битов числа влево на указанное количество позиций.                                                                               | `5 << 1  # 10`                       | `int`                                |
| `>>`              | Сдвиг битов числа вправо на указанное количество позиций.                                                                              | `5 >> 1  # 2`                        | `int`                                |

**Экранированные последовательности**

| Символ            | Описание                                                                                                                              | Пример использования                 | Типы данных                          |
|-------------------|----------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------|--------------------------------------|
| `\n`              | Перевод строки (новая строка).                                                                                                        | `"Hello\nworld!"  # Hello world!`    | `str`                                |
| `\t`              | Табуляция (отступ).                                                                                                                   | `"Hello\tworld!"  # Hello    world!` | `str`                                |
| `\\`              | Обратная косая черта (экран).                                                                                                          | `"C:\\Users\\Admin"`                 | `str`                                |
| `\'`              | Одинарная кавычка внутри строки.                                                                                                       | `'It\'s cool!'`                      | `str`                                |
| `\"`              | Двойная кавычка внутри строки.                                                                                                         | `"She said, \"Hi!\""`                | `str`                                |

# Типы данных в Python

| Тип данных      | Описание                                                                                                      | Пример                             |
|-----------------|--------------------------------------------------------------------------------------------------------------|------------------------------------|
| **int**         | Целое число — тип данных для хранения целых чисел.                                                            | `x = 10`                          |
| **float**       | Число с плавающей запятой (десятичное). Используется для работы с дробными числами.                           | `y = 3.14`                        |
| **str**         | Строка — последовательность символов. Хранит текстовые данные.                                                | `name = "Alice"`                  |
| **bool**        | Логический тип данных. Может иметь только два значения: `True` или `False`.                                   | `is_active = True`                |
| **list**        | Список — изменяемая коллекция объектов. Может хранить данные разных типов, доступ по индексу.                 | `my_list = [1, 2, 3, "hello"]`    |
| **tuple**       | Кортеж — неизменяемая последовательность объектов. Хранит элементы, как и список, но их нельзя изменить.      | `my_tuple = (1, 2, 3)`            |
| **set**         | Множество — неупорядоченная коллекция уникальных элементов.                                                   | `my_set = {1, 2, 3}`              |
| **dict**        | Словарь — изменяемая коллекция пар "ключ-значение". Ключи должны быть уникальными.                            | `my_dict = {"a": 1, "b": 2}`      |
| **NoneType**    | Специальный тип данных, представляющий "ничто". Часто используется для обозначения отсутствия значения.        | `x = None`                        |
| **complex**     | Комплексные числа. Представляют собой числа с реальной и мнимой частью.                                       | `z = 2 + 3j`                      |
| **range**       | Последовательность целых чисел, часто используется в циклах.                                                  | `r = range(1, 10)`                |
| **bytes**       | Последовательность байтов. Используется для работы с бинарными данными.                                        | `b = b"hello"`                    |
| **bytearray**   | Массив байтов — изменяемая версия типа `bytes`.                                                              | `b_array = bytearray(5)`           |
| **frozenset**   | Неизменяемое множество. В отличие от `set`, элементы нельзя добавлять или удалять.                            | `f_set = frozenset([1, 2, 3])`    |
| **memoryview**  | Позволяет работать с бинарными данными без копирования, позволяет ссылаться на часть данных.                   | `m_view = memoryview(b"abc")`      |

**Примечания**
- **Список (list)**: Изменяемый тип данных, поддерживает добавление, удаление и изменение элементов.
- **Кортеж (tuple)**: Неизменяемый, экономит память, можно использовать для защиты от непреднамеренных изменений.
- **Множество (set)**: Элементы уникальны, быстрый поиск, неупорядоченные данные.
- **Словарь (dict)**: Использует ключи для доступа к значениям, можно быстро получать значения по ключу.

## Операции c типами данных `int` и `float`

| Операция/Метод    | Описание                                          | Пример                  | Результат  |
|-------------------|---------------------------------------------------|-------------------------|------------|
| `+`, `-`, `*`, `/`| Операции сложения, вычитания, умножения, деления  | `5 + 3`, `10 / 2`       | `8`, `5.0` |
| `//`, `%`, `**`   | Целочисленное деление, остаток, возведение в степень | `10 // 3`, `10 % 3`, `2 ** 3` | `3`, `1`, `8` |
| `abs()`           | Возвращает абсолютное значение числа              | `abs(-7)`               | `7`        |
| `round()`         | Округляет число                                   | `round(3.14159, 2)`     | `3.14`     |
| `int()`, `float()`| Преобразование в целое или вещественное число     | `int(2.9)`, `float(3)`  | `2`, `3.0` |

## Строки и операции c типом данных `str`

**Строка** (`str`) — это неизменяемая последовательность символов в кодировке Unicode. Строки могут содержать буквы, цифры, пробелы, специальные символы и даже пустую строку.
```python
my_str = "Hello, World!"
```

Для преобразования других типов данных в строку используется встроенная функция `str()`.

Что можно преобразовать в строку?
- Числа (`int`, `float`, `complex`)
- Булевы значения (`True`, `False`)
- Другие объекты — объекты классов, поддерживающих метод `__str__()` или `__repr__()`.
```python
num = 123
print(str(num))  # "123"

boolean_value = True
print(str(boolean_value))  # "True"

list_data = [1, 2, 3]
print(str(list_data))  # "[1, 2, 3]"
```

**Синтаксис создания строки**

- Пустая строка: empty_str = ""
- Обычная строка: my_str = "Hello"
- Многострочная строка (с использованием тройных кавычек):

```python
multiline_str = """This is a
multiline string."""
```

**Операции со строками**

Операция | Описание | Пример
---------|----------|--------
Конкатенация | Склеивание строк. | `"Hello" + " World"`
Повторение | Повтор строки указанное количество раз. | `"Hello" * 3`
Индексация | Доступ к символу по индексу. | `"Hello"[0]`
Длина строки | Возвращает количество символов в строке. | `len("Hello")`
Проверка вхождения | Проверяет, содержится ли подстрока в строке. | `"e" in "Hello"`
Срезы | Извлечение подстроки. | `"Hello"[1:4]`
Переворот строки | Оператор среза с шагом -1. | `"Hello"[::-1]`

**Методы строк**

- `count(sub[, start[, end]])` Возвращает количество вхождений подстроки sub в строке. Опционально можно указать диапазон поиска с помощью `start` и `end`.

```python
text = "Hello, hello, hello!"
print(text.count("hello"))  # 2
```
- `isupper()`
Проверяет, состоит ли строка только из заглавных букв.

```python
text = "HELLO"
print(text.isupper())  # True
```

- `islower()`
Проверяет, состоит ли строка только из строчных букв.

```python
text = "hello"
print(text.islower())  # True
```
- `capitalize()`
Возвращает копию строки с заглавной первой буквой и всеми остальными строчными.

```python
text = "hello world"
print(text.capitalize())  # "Hello world"
```
- `lower()`
Возвращает копию строки, где все символы преобразованы в строчные.

```python
text = "HELLO"
print(text.lower())  # "hello"
```
- `upper()`
Возвращает копию строки, где все символы преобразованы в заглавные.

```python
text = "hello"
print(text.upper())  # "HELLO"
```
- `title()`
Возвращает строку, где первая буква каждого слова — заглавная.

```python
text = "hello world"
print(text.title())  # "Hello World"
```
- `swapcase()`
Меняет регистр каждого символа на противоположный.

```python
text = "Hello World"
print(text.swapcase())  # "hELLO wORLD"
```
- `find(sub[, start[, end]])`
Возвращает индекс первого вхождения подстроки `sub`. Если подстрока не найдена, возвращает -1. Можно указать диапазон поиска с помощью `start` и `end`.

```python
text = "Hello, World!"
print(text.find("World"))  # 7
```
- `replace(old, new[, count])`
Возвращает копию строки, где все вхождения подстроки `old` заменены на `new`. Можно указать количество замен с помощью параметра `count`.

```python
text = "hello world"
print(text.replace("world", "Python"))  # "hello Python"
```
- `strip([chars])`
Возвращает копию строки с удаленными начальными и конечными символами. По умолчанию удаляет пробелы.

```python
text = "  hello  "
print(text.strip())  # "hello"
```
- `startswith(prefix[, start[, end]])`
Проверяет, начинается ли строка с подстроки `prefix`.

```python
text = "hello world"
print(text.startswith("hello"))  # True
```
- `endswith(suffix[, start[, end]])`
Проверяет, заканчивается ли строка подстрокой `suffix`.

```python
text = "hello world"
print(text.endswith("world"))  # True
```
- `split([sep[, maxsplit]])`
Разделяет строку по разделителю sep и возвращает список строк. Можно ограничить количество разделений с помощью `maxsplit`.

```python
text = "hello world"
print(text.split())  # ["hello", "world"]
```
- `join(iterable)`
Возвращает строку, составленную из элементов итерируемого объекта, разделенных строкой, на которой вызван метод.

```python
words = ["hello", "world"]
print(" ".join(words))  # "hello world"
```
- `isdigit()`
Проверяет, состоят ли все символы строки из цифр. Если все символы строки — цифры (0-9), метод возвращает True. В противном случае — False.

```python
"1234".isdigit()     # True: все символы цифры
"12.34".isdigit()    # False: присутствует точка
"123a".isdigit()     # False: есть буква
"".isdigit()         # False: пустая строка
" 1234".isdigit()    # False: пробел в строке
"²".isdigit()        # True: символы, представляющие цифры (например, степени)
```

Примеры работы методов:
```python
# Пример использования метода count
text = "banana"
print(text.count("a"))  # 3

# Пример использования метода isupper
text = "HELLO"
print(text.isupper())  # True

# Пример использования метода islower
text = "hello"
print(text.islower())  # True

# Пример использования метода capitalize
text = "hello world"
print(text.capitalize())  # "Hello world"
```

## Операции c типом данных `bool`

| Операция/Метод | Описание                                | Пример          | Результат |
|----------------|-----------------------------------------|-----------------|-----------|
| `and`, `or`, `not` | Логические операторы                 | `True and False`| `False`   |
| `bool()`       | Преобразует значение в логическое        | `bool(0)`, `bool(1)` | `False`, `True` |
| `is`, `is not` | Сравнение идентичности объектов         | `a is b`        | `True/False` |

## Списки и операции c типом данных `list`

Список — это изменяемая последовательность, которая может содержать элементы любого типа данных. Списки позволяют хранить наборы элементов, обращаться к ним по индексу, изменять, добавлять и удалять элементы.

Списки создаются с помощью квадратных скобок или с использованием функции `list()`.

```python
# Пустой список
my_list = []

# Список с элементами
my_list = [1, 2, 3, "Hello", True]

# Создание списка из другого итерируемого объекта
my_list = list("Hello")  # ['H', 'e', 'l', 'l', 'o']
```
Функция `list()` может преобразовывать итерируемые объекты в список.

**Что можно преобразовать в список?**

- Строки — каждый символ строки станет отдельным элементом списка.
- Кортежи — элементы кортежа будут скопированы в список.
- Множества — преобразуются в список (порядок элементов не гарантирован).
- Диапазоны (range) — преобразуются в список чисел.
- Итерируемые объекты — генераторы, карты, фильтры и т.д. могут быть преобразованы в список.

*Примеры преобразований:*
```python
# Строка в список
string = "Hello"
print(list(string))  # ['H', 'e', 'l', 'l', 'o']

# Кортеж в список
tuple_data = (1, 2, 3)
print(list(tuple_data))  # [1, 2, 3]

# Множество в список
set_data = {10, 20, 30}
print(list(set_data))  # [10, 20, 30]

# Диапазон в список
range_data = range(5)
print(list(range_data))  # [0, 1, 2, 3, 4]
```

**Синтаксис создания списка**<br>
- Пустой список: `my_list = []`
- Список с элементами: `my_list = [1, 2, 3]`
- Использование функции `list(): my_list = list(iterable)`

**Операции со списками**

Операция | Описание | Пример
---------|----------|--------
Индексация | Доступ к элементу по индексу. | my_list[0]
Отрицательная индексация | Доступ к элементу с конца списка. | my_list[-1]
Срезы | Извлечение подсписка. | my_list[1:3]
Конкатенация | Объединение двух списков. | [1, 2] + [3, 4]
Повторение | Повторение элементов списка. | [1, 2] * 3
Проверка на наличие | Проверка, содержится ли элемент в списке. | 3 in [1, 2, 3]
Длина списка | Возвращает количество элементов в списке. | len(my_list)

**Методы списка**

- `append(x)` Добавляет элемент x в конец списка.

```python
my_list = [1, 2, 3]
my_list.append(4)
print(my_list)  # [1, 2, 3, 4]
```

- `extend(iterable)`
Добавляет все элементы из итерируемого объекта в конец списка (отличие от `append`: добавляет не один объект, а все его элементы).

```python
my_list = [1, 2, 3]
my_list.extend([4, 5])
print(my_list)  # [1, 2, 3, 4, 5]
```

- `insert(i, x)` Вставляет элемент x на позицию с индексом i.

```python
my_list = [1, 2, 3]
my_list.insert(1, 10)
print(my_list)  # [1, 10, 2, 3]
```

- `remove(x)` Удаляет первое вхождение элемента x в списке. Если элемент не найден, возникает ошибка ValueError.

```python
my_list = [1, 2, 3, 2]
my_list.remove(2)
print(my_list)  # [1, 3, 2]
```

- `pop([i])` Удаляет и возвращает элемент с индексом i. Если индекс не указан, удаляет и возвращает последний элемент.

```python
my_list = [1, 2, 3]
element = my_list.pop()
print(element)  # 3
print(my_list)  # [1, 2]
```

- `clear()` Очищает список, удаляя все элементы.

```python
my_list = [1, 2, 3]
my_list.clear()
print(my_list)  # []
```

- `index(x[, start[, end]])` Возвращает индекс первого вхождения элемента x в списке. Можно указать диапазон поиска с помощью start и end.

```python
my_list = [1, 2, 3, 2]
print(my_list.index(2))  # 1
```

- `count(x)` Возвращает количество вхождений элемента x в список.

```python
my_list = [1, 2, 3, 2]
print(my_list.count(2))  # 2
```

- `sort(key=None, reverse=False)` Сортирует список на месте. Параметр key позволяет задать функцию для сортировки, а reverse=True — сортировать в обратном порядке.

```python
my_list = [3, 1, 2]
my_list.sort()
print(my_list)  # [1, 2, 3]
```

- `reverse()` Переворачивает список на месте.

```python
my_list = [1, 2, 3]
my_list.reverse()
print(my_list)  # [3, 2, 1]
```

- `copy()` Создает копию списка.

```python
my_list = [1, 2, 3]
my_copy = my_list.copy()
print(my_copy)  # [1, 2, 3]
```
Примеры работы методов:
```python
# Создание списка
my_list = [1, 2, 3]

# append: добавление элемента
my_list.append(4)
print(my_list)  # [1, 2, 3, 4]

# extend: добавление нескольких элементов
my_list.extend([5, 6])
print(my_list)  # [1, 2, 3, 4, 5, 6]

# insert: вставка элемента по индексу
my_list.insert(2, 10)
print(my_list)  # [1, 2, 10, 3, 4, 5, 6]

# remove: удаление элемента
my_list.remove(10)
print(my_list)  # [1, 2, 3, 4, 5, 6]

# pop: удаление последнего элемента
my_list.pop()
print(my_list)  # [1, 2, 3, 4, 5]

# clear: очищение списка
my_list.clear()
print(my_list)  # []
```
**Списковые включения (List comprehension)**

| Операция                | Пример                     | Описание                                              |
|-------------------------|----------------------------|-------------------------------------------------------|
| Создание списка          | `[x**2 for x in range(5)]` | Создаёт список квадратов чисел `[0, 1, 4, 9, 16]`     |
| С фильтрацией элементов  | `[x for x in range(10) if x % 2 == 0]` | Только чётные числа `[0, 2, 4, 6, 8]` |

## Кортежи и операции c типом данных `tuple`

**Кортеж** (`tuple`) — это неизменяемая (immutable) последовательность элементов. Кортежи похожи на списки, но в отличие от списков их нельзя изменить после создания (нельзя добавлять, удалять или изменять элементы).

```python
my_tuple = (1, 2, 3)
```
Кортежи используются, когда требуется обеспечить неизменность данных или для передачи небольших наборов данных, поскольку они занимают меньше памяти, чем списки.

Для преобразования других типов данных в кортеж используется встроенная функция `tuple()`.

**Что можно преобразовать в кортеж?**
- Списки `(list)`
- Строки `(str)`
- Множества `(set)`
- Диапазоны `(range)`
- Другие итерируемые объекты

```python
# Преобразование списка в кортеж
my_list = [1, 2, 3]
print(tuple(my_list))  # (1, 2, 3)

# Преобразование строки в кортеж
my_string = "hello"
print(tuple(my_string))  # ('h', 'e', 'l', 'l', 'o')
```

**Синтаксис создания кортежей**

- Пустой кортеж: `empty_tuple = ()`
- Обычный кортеж: `my_tuple = (1, 2, 3)`
- Один элемент: Чтобы создать кортеж с одним элементом, нужно поставить запятую:
```python
single_element_tuple = (42,)
```
- Без скобок (packing):
```python
my_tuple = 1, 2, 3
```

Кортежи являются неизменяемыми, поэтому попытка изменить элемент кортежа вызовет ошибку `TypeError`:
```python
my_tuple = (1, 2, 3)
my_tuple[0] = 10  # Ошибка: TypeError: 'tuple' object does not support item assignment
```

**Почему кортежи предпочтительнее использовать для передачи данных?**

Кортежи занимают меньше памяти, чем списки, так как не требуют дополнительных ресурсов для изменения их содержимого. Это делает их предпочтительными для передачи больших объемов неизменяемых данных, а также для оптимизации работы программы.
```python
import sys
my_list = [1, 2, 3]
my_tuple = (1, 2, 3)

print(sys.getsizeof(my_list))  # Размер списка 88
print(sys.getsizeof(my_tuple))  # Размер кортежа 64
```

**Методы кортежей**

Метод | Описание | 	Пример
------|----------|----------
count(x) | Возвращает количество вхождений элемента x в кортеже. | `(1, 2, 3, 2).count(2) → 2`
index(x[, start[, end]]) | Возвращает индекс первого вхождения элемента x. | `(1, 2, 3).index(2) → 1`


**Примеры работы методов:**
```python
# Пример использования метода count
my_tuple = (1, 2, 2, 3, 2)
print(my_tuple.count(2))  # 3

# Пример использования метода index
my_tuple = (1, 2, 3, 4)
print(my_tuple.index(3))  # 2
```

**Операции с кортежами**

Операция | Описание | Пример
---------|----------|--------
Конкатенация | Объединение кортежей | (1, 2) + (3, 4)
Повторение | Повторение кортежа несколько раз | (1, 2) * 3
Индексация | Доступ к элементам кортежа по индексу | my_tuple[0]
Срезы | Извлечение части кортежа | my_tuple[1:3]
Проверка вхождения | Проверка, содержится ли элемент в кортеже | 3 in my_tuple
Длина кортежа | Возвращает количество элементов в кортеже | len(my_tuple)

## Множества и операции c типом данных `set`

**Множество** (`set`) — это изменяемая, неупорядоченная коллекция уникальных элементов. Множество не допускает дубликатов и может содержать элементы только неизменяемых типов данных, таких как числа, строки, кортежи.

**Синтаксис создания множества**

1. **Пустое множество**:
   ```python
   my_set = set()  # пустое множество
   ```
2. **Множество с элементами:**
    ```python
    my_set = {1, 2, 3, 4, 5}
    ```
3. **Преобразование в множество:** <br>
    Вы можете преобразовать любую итерируемую коллекцию (например, списки, строки, кортежи) в множество с помощью функции `set()`.

Примеры:
```python
# Преобразование списка в множество
list_to_set = set([1, 2, 2, 3])
print(list_to_set)  # {1, 2, 3}

# Преобразование строки в множество (каждый символ будет уникальным)
str_to_set = set("hello")
print(str_to_set)  # {'h', 'e', 'l', 'o'}

# Преобразование кортежа в множество
tuple_to_set = set((1, 2, 3, 3))
print(tuple_to_set)  # {1, 2, 3}
```

**Важно:** множества содержат только уникальные элементы, поэтому при преобразовании дубликаты автоматически удаляются.

**Методы множества**

Метод | Описание | Пример использования
------|----------|----------------------
`add(elem)`| Добавляет элемент elem в множество. Если элемент уже существует, ничего не происходит.| `my_set.add(10)`
`remove(elem)`| Удаляет элемент elem из множества. Если элемента нет, возникает ошибка KeyError.| `my_set.remove(10)`
`discard(elem)`| Удаляет элемент, если он существует, без ошибки, если элемента нет.| `my_set.discard(10)`
`pop()` | Удаляет и возвращает случайный элемент из множества. Возникает ошибка, если множество пусто.| `my_set.pop()`
`clear()` | Очищает множество, удаляя все элементы. | `my_set.clear()`
`union(*sets)` | Возвращает новое множество, содержащее объединение всех переданных множеств. | `set1.union(set2)`
`intersection(*sets)` | Возвращает новое множество с элементами, присутствующими в каждом из переданных множеств. | `set1.intersection(set2)`
`difference(*sets)` | Возвращает множество, содержащее элементы, присутствующие только в текущем множестве, но не в других. | `set1.difference(set2)`
`symmetric_difference(other_set)` | Возвращает множество, содержащее элементы, которые есть в одном из множеств, но не в обоих. | `set1.symmetric_difference(set2)`
`update(*sets)` | Объединяет текущее множество с другими, добавляя их элементы. | `set1.update(set2)`
`intersection_update(*sets)` | Оставляет в множестве только элементы, присутствующие в каждом из переданных множеств. | `set1.intersection_update(set2)`
`difference_update(*sets)` | Удаляет из множества все элементы, которые присутствуют в переданных множествах. | `set1.difference_update(set2)`
`symmetric_difference_update(other_set)` | Оставляет в множестве элементы, которые есть только в одном из множеств. | `set1.symmetric_difference_update(set2)`
`issubset(other_set)` | Возвращает True, если все элементы текущего множества присутствуют в другом множестве. | `set1.issubset(set2)`
`issuperset(other_set)` | Возвращает True, если все элементы другого множества присутствуют в текущем множестве. | `set1.issuperset(set2)`
`isdisjoint(other_set)` | Возвращает True, если множества не имеют общих элементов. | `set1.isdisjoint(set2)`
`copy()` | Возвращает копию множества. | `set1.copy()`
`len()` | Возвращает количество элементов в множестве. | `len(my_set)`

**Примеры использования методов:**

- Метод `add()`
Добавление нового элемента:

```python
my_set = {1, 2, 3}
my_set.add(4)
print(my_set)  # {1, 2, 3, 4}
```

- Метод `remove()`
Удаление элемента. Если элемента нет, возникает ошибка:

```python
my_set = {1, 2, 3}
my_set.remove(2)
print(my_set)  # {1, 3}
# my_set.remove(10)  # KeyError: 10
```

- Метод `discard()`
Удаление элемента без возникновения ошибки, если элемента нет:

```python
my_set = {1, 2, 3}
my_set.discard(2)
my_set.discard(10)  # Никакой ошибки не возникнет
print(my_set)  # {1, 3}
```

- Метод `union()`
Возвращает объединение множеств:

```python
set1 = {1, 2, 3}
set2 = {3, 4, 5}
union_set = set1.union(set2)
print(union_set)  # {1, 2, 3, 4, 5}
```

- Метод `intersection()`
Возвращает пересечение множеств:

```python
set1 = {1, 2, 3}
set2 = {2, 3, 4}
intersection_set = set1.intersection(set2)
print(intersection_set)  # {2, 3}
```

- Метод `len()`
Возвращает количество элементов в множестве:

```python
my_set = {1, 2, 3, 4}
print(len(my_set))  # 4
```

- Метод `pop()`
Удаляет случайный элемент из множества:

```python
my_set = {1, 2, 3, 4}
elem = my_set.pop()
print(elem)  # Например, 1 (удаленный элемент)
print(my_set)  # Остальные элементы
```

- Метод `isdisjoint()`
Проверяет, есть ли общие элементы между множествами:

```python
set1 = {1, 2, 3}
set2 = {4, 5, 6}
print(set1.isdisjoint(set2))  # True
```

- Метод `issubset()`
Проверяет, является ли одно множество подмножеством другого:

```python
set1 = {1, 2}
set2 = {1, 2, 3}
print(set1.issubset(set2))  # True
```

- Метод `issuperset()`
Проверяет, содержит ли одно множество все элементы другого множества:

```python
set1 = {1, 2, 3}
set2 = {1, 2}
print(set1.issuperset(set2))  # True
```

- Метод `clear()`
Очищает множество:

```python
my_set = {1, 2, 3}
my_set.clear()
print(my_set)  # set()
```


**Особенности использования множества**<br>
- Элементы множества должны быть неизменяемыми: вы не можете использовать списки или другие множества в качестве элементов множества.
- Неупорядоченность: элементы множества не имеют определенного порядка, что значит, что их индексация невозможна.

## Неизменяемые множества и операции c типом данных `frozenset`


Неизменяемое множество `frozenset`, как и обычное множество, содержит только уникальные элементы, но, в отличие от множества, его элементы нельзя изменять после создания. Поскольку `frozenset` неизменяем, его можно использовать в качестве ключей словаря или элементов других множеств.

**Какие типы данных можно преобразовать в `frozenset`?** <br>
`frozenset` может быть создан из **любого итерируемого объекта**, например:

- Список `list`:
- Кортеж `tuple`:
- Строка `str`:
- Диапазон `range`:
- Множество `set`:


**Невозможность преобразования:** <br>
Нельзя преобразовать в frozenset неитерируемые объекты (например, числа, `None`, объекты без метода `__iter__`).

**Синтаксис создания frozenset**

- Пустое неизменяемое множество:

```python
my_frozenset = frozenset()  # пустой frozenset
```

- Создание `frozenset` из итерируемого объекта:

```python
my_frozenset = frozenset([1, 2, 3, 3])  # {1, 2, 3}
```

**Методы неизменяемого множества**

Метод | Описание | Пример использования
------|----------|---------------------
`union(*sets)` | Возвращает новое frozenset, содержащее объединение с другими множествами. | `fs1.union(fs2)`
`intersection(*sets)` | Возвращает новое frozenset с элементами, присутствующими во всех переданных множествах. | `fs1.intersection(fs2)`
`difference(*sets)` | Возвращает новое frozenset с элементами, присутствующими только в первом множестве, но не в других. | `fs1.difference(fs2)`
`symmetric_difference(other_set)` | Возвращает новое frozenset с элементами, которые есть в одном из множеств, но не в обоих. | `fs1.symmetric_difference(fs2)`
`copy()` | Возвращает копию frozenset. | `fs1.copy()`
`isdisjoint(other_set)` | Возвращает True, если frozenset не содержит общих элементов с другим множеством. | `fs1.isdisjoint(fs2)`
`issubset(other_set)` | Возвращает True, если текущее множество является подмножеством другого. | `fs1.issubset(fs2)`
`issuperset(other_set)` | Возвращает True, если текущее множество содержит все элементы другого множества. | `fs1.issuperset(fs2)`
`len()`| Возвращает количество элементов в frozenset. | `len(fs1)`

**Примеры использования методов:**

- Метод `union()`
Объединение двух frozenset:

```python
fs1 = frozenset([1, 2, 3])
fs2 = frozenset([3, 4, 5])
union_frozenset = fs1.union(fs2)
print(union_frozenset)  # frozenset({1, 2, 3, 4, 5})
```

- Метод `intersection()`
Пересечение двух frozenset:

```python
fs1 = frozenset([1, 2, 3])
fs2 = frozenset([2, 3, 4])
intersection_frozenset = fs1.intersection(fs2)
print(intersection_frozenset)  # frozenset({2, 3})
```

- Метод `difference()`
Разница между двумя `frozenset`:

```python
fs1 = frozenset([1, 2, 3])
fs2 = frozenset([2, 3, 4])
difference_frozenset = fs1.difference(fs2)
print(difference_frozenset)  # frozenset({1})
```

- Метод `isdisjoint()`
Проверка, содержат ли множества общие элементы:

```python
fs1 = frozenset([1, 2, 3])
fs2 = frozenset([4, 5, 6])
print(fs1.isdisjoint(fs2))  # True
```

**Примечания**
- Неизменяемость: после создания элементы нельзя добавлять, удалять или изменять.
- `frozenset` полезен, когда нужна неизменяемая коллекция уникальных элементов.
- Использование как ключи словаря: поскольку `frozenset` неизменяем, его можно использовать в качестве ключа словаря или элемента другого множества.

## Словари и операции c типом данных `dict`

**Словарь** (`dict`) — это изменяемая коллекция, содержащая пары ключ-значение. Словари позволяют быстро находить значения по ключам и поддерживают произвольные типы данных в качестве значений.

```python
my_dict = {'name': 'Alice', 'age': 25, 'city': 'New York'}
```

Словари — это одна из наиболее используемых структур данных в Python, так как они обеспечивают эффективный доступ к значениям по ключам.

**Стандартная запись:**
```python
my_dict = {'key1': 'value1', 'key2': 'value2'}
```

**Альтернативная запись через `dict()`:**
```python
my_dict = dict(key1='value1', key2='value2')
```
Cтандартная запись предпочтительнее, так как она более гибкая (поддерживает любой тип ключей) и понятная для большинства разработчиков.

Ключ — это уникальный элемент, с помощью которого можно получить соответствующее ему значение в словаре. Ключ должен быть неизменяемым и хешируемым (например, строки, числа, кортежи).

**Что может быть ключом и значением?**
- **Ключ:** может быть строкой, числом, кортежем или любым другим неизменяемым типом данных.
- **Значение:** может быть объектом любого типа данных, включая другие словари, списки, функции и т.д.
```python
my_dict = {42: 'Answer', (1, 2): 'Tuple Key', 'name': 'Alice'}
```

**Как обращаться к ключам и значениям?**

Доступ к значению осуществляется через ключ:
```python
my_dict = {'name': 'Alice', 'age': 25}
print(my_dict['name'])  # Alice
```

Если ключа нет, возникнет ошибка KeyError. Для безопасного доступа можно использовать метод `get()`:
```python
print(my_dict.get('name'))  # Alice
print(my_dict.get('unknown_key', 'default_value'))  # default_value
```

**Вложенные словари**

Словарь может содержать в качестве значения другой словарь. Для обращения к вложенному словарю используются два уровня ключей:
```python
nested_dict = {'user1': {'name': 'Alice', 'age': 25}, 'user2': {'name': 'Bob', 'age': 30}}

# Доступ к вложенному элементу
print(nested_dict['user1']['name'])  # Alice
```
**Вывод ключей и значений через цикл `for`**

Для получения ключей и значений можно использовать методы `keys()`, `values()`, и `items()`:
```python
# Вывод ключей
for key in my_dict.keys():
    print(key)

# Вывод значений
for value in my_dict.values():
    print(value)

# Вывод ключей и значений
for key, value in my_dict.items():
    print(f'{key}: {value}')
```

**Операции со словарями**

Операция | Описание | Пример
---------|----------|--------
Конкатенация | Объединение двух словарей (но без изменения существующих словарей) | `{**dict1, **dict2}`
Проверка на наличие ключа | Проверка, содержится ли ключ в словаре | `'name' in my_dict`
Удаление ключа | Удаление элемента по ключу | `del my_dict['age']`
| Длина словаря | Возвращает количество пар ключ-значение | `len({'a': 1, 'b': 2})`


**Методы словаря**


Метод | Описание | Пример использования
------|----------|---------------------
`clear()` | Очищает словарь, удаляя все ключи и значения. | `my_dict.clear()`
`pop(key)` | Удаляет элемент по ключу и возвращает его значение. Если ключ не найден, возникает KeyError. | `my_dict.pop('age')`
`popitem()` | Удаляет и возвращает последний добавленный элемент (случайный в версии Python 3.6 и выше). | `my_dict.popitem()`
`keys()` | Возвращает объект, содержащий все ключи словаря. | `my_dict.keys()`
`values()` | Возвращает объект, содержащий все значения словаря. | `my_dict.values()`
`items()` | Возвращает объект, содержащий пары (ключ, значение). | `my_dict.items()`
`update(other)` | Обновляет словарь значениями из другого словаря или итерируемого объекта. | `my_dict.update({'city': 'New York'})`
`get(key, [default])` | Возвращает значение по ключу, если ключ отсутствует — возвращает значение по умолчанию, если указано. | `my_dict.get('name', 'Unknown')`
`setdefault(key, [default])` | Возвращает значение по ключу, если ключ отсутствует — добавляет ключ с указанным значением по умолчанию. | `my_dict.setdefault('age', 18)`
`copy()` | Создает копию словаря. | `new_dict = my_dict.copy()`
`fromkeys(seq, [value])` | Создает новый словарь с ключами из последовательности seq и значением по умолчанию value. | `dict.fromkeys(['name', 'age'], 'Unknown')`


- Метод `clear()`:
Очищает словарь полностью:

```python
my_dict = {'name': 'Alice', 'age': 25}
my_dict.clear()
print(my_dict)  # {}
```
- Метод `pop()`:
Удаляет элемент по ключу и возвращает его значение:

```python
my_dict = {'name': 'Alice', 'age': 25}
age = my_dict.pop('age')
print(age)  # 25
```

- Метод `popitem()`:
Удаляет и возвращает последнюю добавленную пару:

```python
my_dict = {'name': 'Alice', 'age': 25}
item = my_dict.popitem()
print(item)  # ('age', 25)
```

- Метод `keys()`:
Возвращает все ключи словаря:

```python
my_dict = {'name': 'Alice', 'age': 25}
print(list(my_dict.keys()))  # ['name', 'age']
```

- Метод `values()`:
Возвращает все значения словаря:

```python
my_dict = {'name': 'Alice', 'age': 25}
print(list(my_dict.values()))  # ['Alice', 25]
```

Метод `items()`:
Возвращает ключи и значения:

```python
my_dict = {'name': 'Alice', 'age': 25}
print(list(my_dict.items()))  # [('name', 'Alice'), ('age', 25)]
```

Метод `update()`:
Обновляет словарь новыми данными:

```python
my_dict = {'name': 'Alice', 'age': 25}
my_dict.update({'city': 'New York'})
print(my_dict)  # {'name': 'Alice', 'age': 25, 'city': 'New York'}
```

- Метод `get()`:
Возвращает значение по ключу:

```python
my_dict = {'name': 'Alice', 'age': 25}
print(my_dict.get('name'))  # Alice
print(my_dict.get('city', 'Unknown'))  # Unknown
```

- Метод `setdefault()`:
Возвращает значение по ключу или устанавливает значение по умолчанию:

```python
my_dict = {'name': 'Alice'}
age = my_dict.setdefault('age', 30)
print(my_dict)  # {'name': 'Alice', 'age': 30}
```

- Метод `copy()`:
Создает поверхностную копию словаря:

```python
my_dict = {'name': 'Alice'}
new_dict = my_dict.copy()
print(new_dict)  # {'name': 'Alice'}
```

- Метод `fromkeys()`:
Создает новый словарь с заданными ключами и значением по умолчанию:
```python
keys = ['name', 'age']
default_value = 'Unknown'
new_dict = dict.fromkeys(keys, default_value)
print(new_dict)  # {'name': 'Unknown', 'age': 'Unknown'}
```

Правильное оформления вложенного словаря с точки зрения читаемости:
```python
user_data = {
    'user1': {
        'name': 'Alice',
        'age': 25,
        'location': 'New York',
        'preferences': {
            'likes': ['reading', 'hiking', 'cooking'],
            'dislikes': ['crowds', 'loud music']
        }
    },
    'user2': {
        'name': 'Bob',
        'age': 30,
        'location': 'Los Angeles',
        'preferences': {
            'likes': ['sports', 'music'],
            'dislikes': ['cold weather', 'traffic']
        }
    }
}

```
**Объяснение оформления:**<br>
- **Отступы:** Используйте отступы для обозначения уровней вложенности. Это помогает визуально отделить каждый уровень.
- **Ключи и значения:** Каждая пара ключ-значение на отдельной строке, что облегчает восприятие.
- **Группировка:** Связанные данные (например, предпочтения) можно сгруппировать в подсловарь, что делает структуру более логичной.
- **Типы данных:** Вложенные списки и словари оформлены аккуратно, что упрощает дальнейшее обращение к данным.

Такое оформление делает код более понятным и удобным для чтения.

## Операции c типом данных `NoneType`

| Операция/Метод  | Описание                                    | Пример           | Результат |
|-----------------|---------------------------------------------|------------------|-----------|
| `is`            | Проверка идентичности объектов              | `x is None`      | `True`    |
| `==`            | Проверка равенства                          | `x == None`      | `True`    |

## Операции c типом данных `complex`

| Операция/Метод  | Описание                                    | Пример                   | Результат    |
|-----------------|---------------------------------------------|--------------------------|--------------|
| `+`, `-`, `*`, `/` | Операции сложения, вычитания, умножения, деления | `(1+2j) + (2+3j)`         | `(3+5j)`     |
| `abs()`         | Модуль комплексного числа                   | `abs(3+4j)`               | `5.0`        |

## Операции c типом данных `range`

| Операция/Метод  | Описание                                    | Пример                   | Результат    |
|-----------------|---------------------------------------------|--------------------------|--------------|
| `len(range)`    | Возвращает количество элементов в диапазоне | `len(range(1, 10))`       | `9`          |
| `list(range)`   | Преобразует диапазон в список               | `list(range(1, 5))`       | `[1, 2, 3, 4]` |

## Операции c типом данных `bytes`

| Операция/Метод  | Описание                                    | Пример                   | Результат    |
|-----------------|---------------------------------------------|--------------------------|--------------|
| `len(bytes)`    | Возвращает длину байтового объекта          | `len(b'hello')`           | `5`          |
| `decode()`      | Декодирует байтовую строку в строку         | `b'hello'.decode()`       | `'hello'`    |

## Операции c типом данных `bytearray`

| Операция/Метод  | Описание                                    | Пример                   | Результат    |
|-----------------|---------------------------------------------|--------------------------|--------------|
| `append(item)`  | Добавляет байт в конец                      | `ba.append(255)`          | `bytearray(b'\xff')` |
| `decode()`      | Декодирует байтовую строку                  | `bytearray(b'hello').decode()` | `'hello'` |

## Операции c типом данных `memoryview`

| Операция/Метод  | Описание                                    | Пример                   | Результат    |
|-----------------|---------------------------------------------|--------------------------|--------------|
| `tobytes()`     | Преобразует представление в байты           | `mview.tobytes()`         | `b'hello'`   |
| `tolist()`      | Преобразует представление в список          | `mview.tolist()`          | `[104, 101, 108, 108, 111]` |

## Индексы и срезы

**Индексы** — это числовые позиции элементов в последовательностях, таких как строки, списки, кортежи. Индексация начинается с 0, т.е. первый элемент последовательности имеет индекс 0, второй — 1 и т.д.

**Срезы** — это операция извлечения подмножества элементов из последовательности с указанием диапазона индексов. Позволяют извлекать несколько элементов сразу, используя синтаксис `[start:stop:step]`.

**Обращение к элементу по индексу**

```python
my_list = [10, 20, 30, 40, 50]
print(my_list[0])  # 10 (первый элемент)
print(my_list[2])  # 30 (третий элемент)
```

**Обращение по отрицательному индексу**

Отрицательные индексы позволяют обращаться к элементам с конца последовательности. Например, -1 — это последний элемент, -2 — предпоследний и так далее.

```python
my_list = [10, 20, 30, 40, 50]
print(my_list[-1])  # 50 (последний элемент)
print(my_list[-2])  # 40 (предпоследний элемент)
```

**Вложенные последовательности**

Вложенные списки (или другие последовательности) — это структуры данных, в которых один или несколько элементов являются другими списками или коллекциями. Доступ к элементам вложенных списков осуществляется через несколько индексов.

**Пример вложенного списка:**
```python
nested_list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
print(nested_list[0])     # [1, 2, 3] (первый вложенный список)
print(nested_list[1][2])  # 6 (третий элемент второго списка)
```

**Пример вложенного словаря:**
```python
nested_dict = {'key1': {'subkey1': 100}, 'key2': {'subkey2': 200}}
print(nested_dict['key1']['subkey1'])  # 100 (доступ к вложенному значению)
```

**Индексы и срезы в различных типах данных**

Тип данных | Индексация | Срезы | Примечания
-----------|------------|-------|------------
Строки | Да | Да | Индексы позволяют извлекать символы, срезы — подстроки.
Списки | Да | Да | Индексы извлекают элементы, срезы — подсписки.
Кортежи | Да | Да | Работает аналогично спискам.
Множества | Нет | Нет | Множества не поддерживают индексацию.
Словари | Нет | Нет | Доступ к значениям осуществляется через ключи, а не индексы.
Диапазоны | Да | Да | Работает как со списками.
Bytes | Да | Да | Индексация и срезы работают как со строками.


**Срезы: синтаксис и параметры**

Срезы позволяют извлекать подмножество элементов последовательности. Общий синтаксис:
```python
sequence[start:stop:step]
```

**Параметры среза:**

- `start`: Индекс начала среза (включительно). По умолчанию — 0.
- `stop`: Индекс конца среза (не включается). По умолчанию — длина последовательности.
- `step`: Шаг среза. По умолчанию — 1 (последовательно по порядку).

Пример использования срезов:
```python
my_list = [10, 20, 30, 40, 50]

# Простой срез
print(my_list[1:4])  # [20, 30, 40] (второй до четвертого элемента)

# Пропуск шага
print(my_list[::2])  # [10, 30, 50] (каждый второй элемент)

# Срез с отрицательным шагом
print(my_list[::-1])  # [50, 40, 30, 20, 10] (переворот списка)
```
Пример срезов строк:
```python
my_string = "Hello, World!"

# Срез от второго до пятого символа
print(my_string[1:5])  # 'ello'

# Взятие каждого второго символа
print(my_string[::2])  # 'Hlo ol!'
```

**Переворот последовательностей через срезы**

Использование отрицательного шага -1 в срезах позволяет развернуть последовательность. Это особенно полезно для разворота списков и строк.

Пример переворота:
```python
my_list = [10, 20, 30, 40, 50]
print(my_list[::-1])  # [50, 40, 30, 20, 10] (перевернутый список)
```
Пример переворота строки:
```python
my_string = "Python"
print(my_string[::-1])  # 'nohtyP' (перевернутая строка)
```
**Особенности срезов:**

**Открытые границы:** Если не указать `start`, срез начнётся с начала последовательности. Если не указать stop, срез будет идти до конца.
```python
my_list = [10, 20, 30, 40, 50]
print(my_list[:3])   # [10, 20, 30] (срез до третьего элемента)
print(my_list[2:])   # [30, 40, 50] (срез с третьего до конца)
```

**Отрицательные индексы:** Срезы также поддерживают отрицательные индексы, что позволяет задавать границы с конца последовательности.
```python
my_list = [10, 20, 30, 40, 50]
print(my_list[-3:])  # [30, 40, 50] (последние три элемента)
```

**Срез с шагом больше 1:** Можно пропускать элементы с помощью шага. Например, с шагом 2 будут браться только каждый второй элемент.
```python
my_list = [10, 20, 30, 40, 50]
print(my_list[::2])  # [10, 30, 50] (каждый второй элемент)
```
Пример 1: Извлечение подстроки
```python
text = "Hello, Python!"
substring = text[7:13]
print(substring)  # 'Python'
```

Пример 2: Удаление элемента из списка с помощью срезов
```python
my_list = [10, 20, 30, 40, 50]
new_list = my_list[:2] + my_list[3:]
print(new_list)  # [10, 20, 40, 50] (без третьего элемента)
```

Пример 3: Переворот строки
```python
name = "Python"
reversed_name = name[::-1]
print(reversed_name)  # 'nohtyP'
```

# Основные функции языка Python

## Функция `input()`

**Описание**:

Функция для получения пользовательского ввода через консоль. Возвращает данные в виде строки.

**Синтаксис**:
  ```python
  input(prompt)
  ```
`prompt`: (необязательно) строка, отображаемая пользователю перед вводом.

Пример:
```python
name = input('Enter your name: ')
```
**Особенности:**

Функция всегда возвращает строку. Для работы с числами нужно преобразовать строку в нужный тип данных:

`int()` — для целых чисел, <br>
`float()` — для вещественных чисел.

Пример:

```python
age = int(input("Enter your age: "))  # Преобразование строки в целое число
```

## Функция `print()`

**Описание:**

 Функция `print()` выводит данные в консоль. Она может принимать несколько объектов и объединять их через разделитель.

**Синтаксис:**
```python
print(*objects, sep=' ', end='\n', file=sys.stdout, flush=False)
```

- `*objects`: объекты для вывода. <br>
- `sep`: строка-разделитель между объектами (по умолчанию пробел ' '). <br>
- `end`: строка, добавляемая в конце (по умолчанию новая строка '\n'). <br>
- `file`: объект для вывода (по умолчанию консоль sys.stdout). <br>
- `flush`: если True, сбрасывает буфер вывода сразу (по умолчанию False). <br>

Пример:
```python
# Обычный вывод с пробелами
print("Hello", "world")
# Вывод: Hello world
```

1.  Параметр `sep` (разделитель): <br>
Изменяет строку, которая вставляется между объектами: <br>
Пример: <br>
```python
print("apple", "banana", "cherry", sep=" | ")
# Вывод: apple | banana | cherry
```

2. Параметр `end` (окончание): <br>
Управляет тем, что будет в конце строки (по умолчанию новая строка):
```python
print("Hello", end="!!! ")
print("World")
# Вывод: Hello!!! World
```

3. Запись в файл с помощью `file`: <br>
Можно перенаправить вывод в файл:
```python
with open("output.txt", "w") as f:
    print("Logging this message", file=f)
```

4. Параметр `flush` (сброс буфера): <br>
Используется для немедленного вывода, без задержки:
```python
import time
for i in range(3):
    print(i, flush=True, end=" ")
    time.sleep(1)
# Вывод с задержкой: 0 1 2
```

## Форматирование строк с помощью f-строк

**Описание:** <br>
 f-строки (или форматированные строки) позволяют вставлять значения переменных прямо в строку. Это удобно для создания динамических сообщений.

**Синтаксис:**
```python
f"текст {переменная} текст"
```
**Где используются:** <br>
 f-строки часто используются в функции `print()`, когда нужно вывести значения переменных вместе с текстом.


Пример:
```python
name = "Alice"
age = 25
print(f"Name: {name}, Age: {age}")
# Вывод: Name: Alice, Age: 25
```
**Особенности:**

f-строки поддерживают любые выражения внутри фигурных скобок:
```python
print(f"The sum of 2 and 3 is {2 + 3}")
# Вывод: The sum of 2 and 3 is 5
```

Можно применять функции:<br>
```python
print(f"The length of 'hello' is {len('hello')}")
# Вывод: The length of 'hello' is 5
```



**Альтернативные методы форматирования строк:**

Метод `str.format()`
```python
name = "Alice"
age = 25
print("Name: {}, Age: {}".format(name, age))
# Вывод: Name: Alice, Age: 25
```
**Старый способ форматирования с `%`:**

Старый способ форматирования строк с помощью оператора `%` — это способ форматирования, который использовался в Python до появления метода `.format()` и f-строк. Он позволяет вставлять значения в строку через подстановочные символы, используя `%` в комбинации с типом данных.

Старый способ с `%` постепенно устаревает, и f-строки или метод `.format()` считаются более предпочтительными, так как они гибче и удобнее в использовании. Однако, `%` всё ещё поддерживается в современных версиях Python для обратной совместимости.

**Синтаксис:**
```python
"строка с %<формат> символом" % (значение)
```
- % используется для указания места, где будет вставлено значение.
- Символы форматирования указывают тип данных, которые нужно вставить. <br>

**Примеры форматирования:**

Символ | Описание | Пример
---  | --- | ---
%s | Строка | "Hello %s" % "world" → Hello world
%d | Целое число | "I have %d apples" % 5 → I have 5 apples
%f |Число с плавающей точкой | "Price is %f dollars" % 2.5 → Price is 2.500000 dollars
%x | Шестнадцатеричное число | "Hex: %x" % 255 → Hex: ff
%% | Символ процента | "Discount: 10%%" → Discount: 10%

Для чисел с плавающей точкой, можно задать количество знаков после запятой (например, %.2f для двух знаков).


**Пример использования:**
```python
name = "Alice"
age = 25
height = 1.68

# Используем % для форматирования строки
message = "Name: %s, Age: %d, Height: %.2f" % (name, age, height)
print(message)
# Вывод: Name: Alice, Age: 25, Height: 1.68
```


## Функция `min()`

**Описание**: <br>
Возвращает минимальное значение среди переданных аргументов или в итерации (список, кортеж и т.д.).

**Типы данных**:

Работает с числами (int, float), строками (str), последовательностями (list, tuple).



**Синтаксис**:

  ```python
  min(iterable, *[, default=obj, key=func])
  min(arg1, arg2, *args[, key=func])
```

- `iterable`: любой итерируемый объект (например, список или кортеж).

- `arg1`, `arg2`, *args: несколько аргументов для сравнения.

- `default`: значение, возвращаемое, если итерация пуста (для итерируемых объектов).

- `key`: функция для указания, по какому критерию искать минимум (например, длина строки).

Пример:
```python
# Минимум среди чисел
print(min(3, 5, 2, 10))  # Вывод: 2

# Минимум среди строк (по алфавиту)
print(min("apple", "banana", "cherry"))  # Вывод: apple

# Минимум в списке
numbers = [10, 20, 5, 40]
print(min(numbers))  # Вывод: 5

# Использование параметра key
words = ["apple", "banana", "cherry"]
print(min(words, key=len))  # Вывод: apple (самое короткое слово)
```

## Функция `max()`

**Описание:**

Возвращает максимальное значение среди переданных аргументов или в итерации (список, кортеж и т.д.).

**Типы данных:**

 Работает с числами (int, float), строками (str), последовательностями (list, tuple).

**Синтаксис:**

```python
max(iterable, *[, default=obj, key=func])
max(arg1, arg2, *args[, key=func])
```

- `iterable`: итерируемый объект (например, список или кортеж).
- `arg1`, `arg2`, `*args`: несколько чисел или строк для сравнения.
- `default`: значение, возвращаемое, если итерация пуста.
- `key`: функция для указания, по какому критерию искать максимум.

```python
# Максимум среди чисел
print(max(3, 5, 2, 10))  # Вывод: 10

# Максимум среди строк (по алфавиту)
print(max("apple", "banana", "cherry"))  # Вывод: cherry

# Максимум в списке
numbers = [10, 20, 5, 40]
print(max(numbers))  # Вывод: 40

# Использование параметра key
words = ["apple", "banana", "cherry"]
print(max(words, key=len))  # Вывод: banana (самое длинное слово)
```

## Функция `abs()`

**Описание:**

 Возвращает абсолютное значение числа, то есть его модуль (расстояние до нуля на числовой оси).

**Типы данных:**

 Работает с числами (int, float, complex).

**Синтаксис:**

```python
abs(x)
```
`x`: число (целое, вещественное или комплексное).

Примеры:

```python
# Абсолютное значение целого числа
print(abs(-10))  # Вывод: 10

# Абсолютное значение вещественного числа
print(abs(-3.14))  # Вывод: 3.14

# Абсолютное значение комплексного числа (модуль)
print(abs(3 + 4j))  # Вывод: 5.0 (поскольку sqrt(3^2 + 4^2) = 5)
```

## Функция `pow()`

**Описание:**

 Возвращает результат возведения числа в степень, при необходимости — с модулем.

**Типы данных:**

 Работает с числами (int, float).

**Синтаксис:**

```python
pow(x, y[, z])
```
- `x`: основание степени.
- `y`: показатель степени.
- `z`: необязательный параметр — модуль (возвращает результат по модулю z).

```python
# Возведение числа в степень
print(pow(2, 3))  # Вывод: 8

# Возведение числа в степень с модулем
print(pow(2, 3, 5))  # Вывод: 3 (2^3 = 8, а 8 % 5 = 3)
```

## Функция `round()`

**Описание:**

 Округляет число до ближайшего целого или до указанного количества знаков после запятой.

**Типы данных:**

 Работает с числами (int, float).

**Синтаксис:**
```python
round(number[, ndigits])
```

- `number`: число для округления.
- `ndigits`: необязательный параметр, определяющий количество знаков после запятой. Если не указан, округляет до ближайшего целого.

Примеры:
```python
# Округление до ближайшего целого
print(round(3.14159))  # Вывод: 3

# Округление до двух знаков после запятой
print(round(3.14159, 2))  # Вывод: 3.14

# Округление до одного знака после запятой
print(round(5.678, 1))  # Вывод: 5.7
```

## Директива `del`

**Назначение**:

Удаляет переменную, элементы или срезы из коллекций.

**Синтаксис**:
  ```python
  del object_name
  del object_name[index]
  del object_name[start:end]
  ```
**Удаление переменных**

Можно использовать `del` для удаления переменной, после чего она перестает существовать в программе.

Пример:
```python
a = 10
print(a)  # Вывод: 10

del a
# print(a)  # Ошибка: переменная 'a' больше не существует
```

**Удаление элементов списка**

Можно удалить элемент из списка по его индексу.

Пример:

```python
my_list = [1, 2, 3, 4, 5]
del my_list[2]  # Удаляет элемент с индексом 2 (значение 3)
print(my_list)  # Вывод: [1, 2, 4, 5]
```

**Удаление среза списка**

Можно удалить сразу несколько элементов, используя срезы.

```python
my_list = [1, 2, 3, 4, 5]
del my_list[1:3]  # Удаляет элементы с индексами 1 и 2 (значения 2 и 3)
print(my_list)  # Вывод: [1, 4, 5]
```

**Удаление элементов словаря**

Можно удалить элемент из словаря по его ключу.

Пример:

```python
my_dict = {'a': 1, 'b': 2, 'c': 3}
del my_dict['b']  # Удаляет ключ 'b' и его значение
print(my_dict)  # Вывод: {'a': 1, 'c': 3}
```

**Удаление объектов в кортежах и строках**

**`Важно`**: Кортежи и строки — неизменяемые типы данных, поэтому del не может удалить их элементы напрямую. Однако можно удалить весь объект.

Пример:
```python
my_tuple = (1, 2, 3)
del my_tuple  # Удаление целого кортежа
# print(my_tuple)  # Ошибка: объект 'my_tuple' больше не существует
```

**Удаление объектов из глобальной области видимости**

Можно удалить переменную, доступную глобально.

Пример:
```python
global_var = "I'm global!"
del global_var  # Удаляет глобальную переменную
# print(global_var)  # Ошибка: переменная 'global_var' больше не существует
```

**Использование в циклах**

`del` может быть использован внутри циклов для удаления элементов по определенному условию.

Пример:
```python
my_list = [10, 20, 30, 40, 50]
for i in range(len(my_list) - 1, -1, -1):  # Обратный цикл
    if my_list[i] == 30:
        del my_list[i]
print(my_list)  # Вывод: [10, 20, 40, 50]
```

**Примечания:**
- После удаления объекта или переменной она становится недоступной в программе.
- При удалении элемента по индексу или ключу, если он не существует, возникнет ошибка IndexError или KeyError.

## Условный оператор `if`

Условный оператор `if` позволяет выполнить блок кода, если заданное условие является `True`.

```python
if условие:
    # код, который выполнится, если условие истинно
```
Пример:
```python
x = 5
if x > 3:
    print("x больше 3")
```
```Результат
x больше 3
```

**Оператор `else`** используется для выполнения кода, если условие в блоке `if` ложно.

```python
x = 2
if x > 3:
    print("x больше 3")
else:
    print("x меньше или равно 3")
```
```Результат
x меньше или равно 3
```

**Оператор `elif`** (сокращение от "`else` `if`") проверяет дополнительные условия, если предыдущее условие оказалось ложным. Количество операторов `elif` не ограничено.

```python
x = 4
if x > 5:
    print("x больше 5")
elif x == 4:
    print("x равно 4")
else:
    print("x меньше 5")
```
```Результат
x равно 4
```
**Вложенные условия (Nested `if`)**

Условные операторы можно вкладывать друг в друга для проверки сложных условий.

```python
x = 10
if x > 5:
    if x < 20:
        print("x между 5 и 20")
    else:
        print("x больше 20")
else:
    print("x меньше или равно 5")
```
```
x между 5 и 20
```

**Оператор `if` с логическими операторами**

Условие в операторе `if` может включать логические операторы (`and`, `or`, `not`).

```python
x = 6
if x > 5 and x < 10:
    print("x больше 5 и меньше 10")
```
```
x больше 5 и меньше 10
```

**Тернарный оператор (Условное выражение)**

**Определение:** <br>
Тернарный оператор — это способ записать условие и его возможные результаты в одну строку кода. В Python используется следующий синтаксис:
```python
result = выражение_если_True if условие else выражение_если_False
```
Этот оператор позволяет присваивать переменной одно из двух значений в зависимости от условия.

```python
x = 10
message = "x больше 5" if x > 5 else "x меньше или равно 5"
print(message)
```
```
x больше 5
```
```python
age = 18
status = "Adult" if age >= 18 else "Minor"
print(status)
```
```
Adult
```
**Особенности тернарного оператора:**

- Тернарный оператор удобен для простых условий, которые можно уместить в одну строку.
- Тернарный оператор может быть использован в выражениях, но его не рекомендуется применять для сложных логических условий из-за снижения читабельности кода.

Тернарный оператор можно использовать с функцией print для компактного вывода:

```python
x = 7
print("x больше 5" if x > 5 else "x меньше или равно 5")
```
```
x больше 5
```

Условие можно использовать для выполнения действий внутри цикла или другого блока кода:
```python
for i in range(1, 6):
    print(f"{i} - четное" if i % 2 == 0 else f"{i} - нечетное")
```
```
1 - нечетное
2 - четное
3 - нечетное
4 - четное
5 - нечетное
```

**Подробности работы условного оператора `if`:**

Python автоматически преобразует значения в логические в условных операторах.

Например: `0`, `None`, пустые коллекции (`[]`, `{}`, `""`) рассматриваются как `False`.
Все остальные значения рассматриваются как `True`.

```python
x = []
if x:
    print("Список не пуст")
else:
    print("Список пуст")
```
```
Список пуст
```
```python
x = None
if x is None:
    print("x имеет значение None")
else:
    print("x не None")
```
```
x имеет значение None
```

## Циклы `for` и `while`

**Цикл `for`** используется для перебора (итерации) по элементам коллекции (например, списков, строк, кортежей, множеств или словарей) или для итерации по числовым диапазонам.

**Сценарии использования:**
- Перебор всех элементов списка или другого итерируемого объекта.
- Выполнение кода определенное количество раз с помощью функции `range()`.

```python
for элемент in коллекция:
    # блок кода
```

Пример 1: Перебор элементов списка
```python
fruits = ["apple", "banana", "cherry"]
for fruit in fruits:
    print(fruit)
```
```
apple
banana
cherry
```
Пример 2: Перебор числового диапазона с использованием `range()`
```python
for i in range(1, 5):
    print(i)
```
```
1
2
3
4
```
Пример 3: Перебор символов строки
```python
for letter in "hello":
    print(letter)
```
```
h
e
l
l
o
```


**Цикл `while`** выполняет блок кода до тех пор, пока условие истинно.

**Сценарии использования:** <br>
- Выполнение блока кода до тех пор, пока не изменится условие.
- Используется для выполнения задач с неизвестным количеством итераций, например, при ожидании определённого события.

```python
while условие:
    # блок кода
```
Пример: Цикл `while` с условием

```python
x = 1
while x < 5:
    print(x)
    x += 1
```
```
1
2
3
4
```
**Бесконечный цикл** возникает, когда условие всегда истинно. Обычно используется для создания циклов, которые будут прерваны внутри с помощью оператора `break`.

Пример бесконечного цикла:
```python
while True:
    print("Этот цикл бесконечный!")
    break  # Прерывание цикла
```

**Применение:**
- Цикл ожидания определённого события.
- Постоянные запросы пользователю, например, для выбора команды в меню.

**Операторы управления циклом**

**Оператор `break`** используется для немедленного выхода из цикла. После вызова `break`, выполнение цикла прекращается, и программа переходит к следующему блоку кода.

Пример с `for`:
```python
for i in range(10):
    if i == 5:
        break  # Прерывание цикла, если i равно 5
    print(i)
```
```
0
1
2
3
4
```
Пример с `while`:
```python
x = 0
while x < 10:
    if x == 5:
        break  # Прерывание цикла, если x равно 5
    print(x)
    x += 1
```
```
0
1
2
3
4
```

**Оператор `continue`** прерывает текущую итерацию цикла и переходит к следующей, не выполняя оставшийся код в блоке.

Пример с `for`:
```python
for i in range(5):
    if i == 3:
        continue  # Пропуск итерации, если i равно 3
    print(i)
```
```
0
1
2
4
```
Пример с `while`:
```python
x = 0
while x < 5:
    x += 1
    if x == 3:
        continue  # Пропуск итерации, если x равно 3
    print(x)
```
```
1
2
4
5
```

**Оператор `else`** может использоваться с циклами `for` и `while`. Он выполняется, когда цикл завершается нормально, то есть без использования `break`.

Пример с `for`:
```python
for i in range(5):
    print(i)
else:
    print("Цикл завершен")
```
```
0
1
2
3
4
Цикл завершен
```
Пример с `while`:
```python
x = 0
while x < 5:
    print(x)
    x += 1
else:
    print("Цикл завершен")
```
```
0
1
2
3
4
Цикл завершен
```

**Примечание:**

 Если цикл прерывается с помощью `break`, блок `else` не выполняется.

Пример с `break`:
```python
for i in range(5):
    if i == 3:
        break  # Прерывание цикла
    print(i)
else:
    print("Цикл завершен")
```
```
0
1
2
```

**Функция `pass`** используется как заглушка в циклах или других конструкциях, где нужен синтаксически корректный блок, но вы пока не хотите писать код.

Пример с `for`:
```python
for i in range(5):
    if i == 3:
        pass  # Ничего не делаем, просто пропускаем
    print(i)
```
```
0
1
2
3
4
```
**Когда использовать `for` и когда `while`?**

- `for` используется, когда известно количество итераций, или при работе с итерируемыми объектами (списки, строки, диапазоны и т.д.).
- `while` используется, когда количество итераций неизвестно заранее, и цикл продолжается до тех пор, пока условие остаётся истинным.

## Функция range()

Функция `range()` генерирует последовательность чисел и возвращает объект, который является итерируемым объектом. В Python 3 функция возвращает объект `range`, а не список.

Синтаксис:
```python
range(stop)
range(start, stop)
range(start, stop, step)
```

**Описание параметров:**

- `start` (необязательно): Число, с которого начинается последовательность. По умолчанию равно 0.
- `stop` (обязательно): Число, при достижении которого последовательность останавливается (не включается в диапазон).
- `step` (необязательно): Шаг, с которым увеличивается (или уменьшается) значение. По умолчанию равен 1. Может быть отрицательным для создания убывающих последовательностей.

Возвращает объект типа `range`, который является итерируемым объектом (может быть преобразован в список, кортеж и т.д.).

Пример 1: Использование одного параметра (только `stop`)

```python
for i in range(5):
    print(i)
```
```
0
1
2
3
4
```
Пример 2: Использование двух параметров (`start` и `stop`)
```python
for i in range(2, 6):
    print(i)
```
```
2
3
4
5
```
Пример 3: Использование трех параметров (`start`, `stop` и `step`)
```python
for i in range(1, 10, 2):
    print(i)
```
```
1
3
5
7
9
```
Пример 4: Обратный порядок (отрицательный шаг)
```python
for i in range(10, 0, -2):
    print(i)
```
```
10
8
6
4
2
```
Пример 5: Преобразование объекта `range` в список
```python
numbers = list(range(5))
print(numbers)
````
```
[0, 1, 2, 3, 4]
```
Пример 6: Преобразование в кортеж
```python
numbers = tuple(range(3, 8))
print(numbers)
```
```
(3, 4, 5, 6, 7)
```
**Особенности и ограничения**

- Невключение `stop` в диапазон: Последнее число, указанное в параметре `stop`, не входит в последовательность.

- Отрицательные шаги: Можно использовать отрицательное значение для `step`, чтобы создавать убывающие последовательности.

- Большие диапазоны: Объект `range` не создаёт полный список в памяти, что позволяет экономить память при работе с большими диапазонами. Его можно итерировать "на лету".

Пример 7: Экономия памяти
```python
big_range = range(1000000)
print(len(big_range))  # 1000000
```
```
1000000
```

**Совместимость с типами данных**

Целые числа `int`: Функция `range()` работает только с целыми числами. Использование с числами с плавающей запятой или другими типами данных вызовет ошибку.

Пример: Ошибка с использованием нецелых значений
```python
range(1.5, 5)  # Ошибка TypeError: 'float' object cannot be interpreted as an integer
```

**Полезные советы:**
Использование в циклах: Самый распространённый сценарий использования функции `range()` — это циклы `for`.

Использование с функцией `len()`: Часто используется для создания индексов при итерации по последовательностям.

Пример 8: Итерация по индексам с помощью `range()` и `len()`

```python
names = ["Alice", "Bob", "Charlie"]
for i in range(len(names)):
    print(f"{i}: {names[i]}")
```
```
0: Alice
1: Bob
2: Charlie
```

## Функция len()

Функция `len()` используется для получения количества элементов (длины) объекта. Она работает с различными типами данных, включая последовательности и коллекции.
```python
len(s)
```
**Параметры:** <br>
s: Объект, длину которого необходимо получить. Это может быть любой итерируемый объект или коллекция (например, строка, список, кортеж, множество, словарь).

**Возвращаемое значение:** <br>
Функция возвращает целое число, которое является количеством элементов в объекте.

**Примеры использования:**

Пример 1: Строка
```python
string = "Hello"
print(len(string))  # 5
```

Пример 2: Список
```python
my_list = [1, 2, 3, 4]
print(len(my_list))  # 4
```

Пример 3: Кортеж
```python
my_tuple = (10, 20, 30)
print(len(my_tuple))  # 3
```

Пример 4: Диапазон (range)
```python
my_range = range(5)
print(len(my_range))  # 5
```

Пример 5: Множество
```python
my_set = {1, 2, 3, 4, 5}
print(len(my_set))  # 5
```

Пример 6: Словарь
```python
my_dict = {'a': 1, 'b': 2, 'c': 3}
print(len(my_dict))  # 3
```

Пример 7: Строка (пустая)
```python
empty_str = ""
print(len(empty_str))  # 0
```

Пример 8: Пустой список
```python
empty_list = []
print(len(empty_list))  # 0
```

Пример 9: Пустой кортеж
```python
empty_tuple = ()
print(len(empty_tuple))  # 0
```
Пример 10: Пустое множество
```python
empty_set = set()
print(len(empty_set))  # 0
```

Пример 11: Пустой словарь
```python
empty_dict = {}
print(len(empty_dict))  # 0
```

**Ошибки при неправильном использовании:**

Функция `len()` работает только с итерируемыми объектами. Попытка применить её к объекту, который не является итерируемым, приведёт к ошибке.

Пример 12: Ошибка при использовании с неитерируемым объектом

```python
number = 10
print(len(number))  # Ошибка TypeError: object of type 'int' has no len()
```

**Особенности:** <br>
**Время выполнения:** Функция `len()` работает за константное время O(1) для объектов, которые хранят информацию о своей длине (например, списки и строки). Однако для некоторых объектов (например, итерируемых генераторов) вычисление длины может занять больше времени.

**Применимость:** Функция `len()` не может быть применена к объектам, которые не являются коллекциями или последовательностями (например, целым числам, числам с плавающей запятой).

Пример 13: Использования `len()` в условном операторе:
```python
my_list = [1, 2, 3]

if len(my_list) > 0:
    print("Список не пустой")
else:
    print("Список пустой")
```
```
Список не пустой
```
**Совместимость с типами данных:**

Тип данных         | Поддерживается `len()`
|------------------|----------------------
| Строки (str)     | Да
|Списки (list)     | Да
|Кортежи (tuple)   | Да
|Множества (set)   | Да
|Словари (dict)    | Да
|Диапазоны (range) | Да
|Генераторы        | Нет
|Целые числа (int) | Нет


## Функция `def`

**Функция** — это именованный блок кода, который выполняет конкретную задачу и может быть вызван в любом месте программы многократно.

Функции помогают:

- Избежать дублирования кода.
- Упрощать структуру программы.
- Повысить читаемость и повторное использование кода.
- Инкапсулировать логику.

Функции также могут принимать **входные параметры** и **возвращать значения**, что делает их гибкими и полезными.

**Зачем нужна функция?**

Функции помогают организовывать код и делать его модульным, позволяя разделять логику программы на более мелкие задачи. Это упрощает тестирование, сопровождение и масштабирование кода. Вместо того чтобы переписывать одно и то же множество раз, можно вызвать функцию, передав ей необходимые аргументы.

**Синтаксис функции**

Для определения функции используется ключевое слово `def`:

```python
def имя_функции(параметры):
    """Докстринг, описывающий функцию (необязательно)"""
    блок_кода
    return значение  # (необязательно)
```

**Основные компоненты:** <br>
- `def` — ключевое слово, которое говорит Python, что мы создаем функцию.
- `имя_функции` — имя функции, следующее за def.
- `параметры` — значения, передаваемые в функцию. Могут быть необязательными. Параметры заключены в круглые скобки.
- `блок_кода` — тело функции, которое выполняется при вызове.
- `return` — используется для возврата значения из функции (необязательный).

Пример функции:
```python
def greet(name):
    """Функция приветствия пользователя"""
    return f"Привет, {name}!"
```
Вызов функции:
```python
print(greet("Анна"))  # Выведет: Привет, Атид!
```

**Название функции**
- Имя функции должно быть говорящим, описывающим то, что она делает.
- Правила для имени:
    - Может содержать буквы, цифры и символ подчеркивания (_).
    - Нельзя начинать с цифры (например, 1function — недопустимо).
    - Нельзя использовать зарезервированные слова Python (например, def, return, if и т.д.).
    - Следует использовать нижний регистр и разделять слова подчеркиваниями, чтобы имя было читаемым (например, calculate_sum).
- Почему нельзя использовать специальные символы:
    - Специальные символы (например, @, !, $) зарезервированы для других синтаксических элементов и могут вызвать синтаксические ошибки.

**Какие типы данных могут быть параметрами функции?**

- Числа (`int`, `float`):
- Строки (`str`):
- Списки (`list`):
- Кортежи (`tuple`), словари (`dict`), множества (`set`) и другие сложные структуры данных

**Виды параметров в функции**

В Python функции могут принимать несколько типов параметров. Это помогает создавать более гибкие функции.

1. **Обязательные параметры**

    Это параметры, которые **должны быть переданы** при вызове функции. Без них функция не сможет выполниться.

    Пример:
    ```python
    def greet(name):
        return f"Привет, {name}!"

    greet("Анна")  # Выведет: Привет, Анна!
    ```
    Здесь `name` — обязательный параметр, его нужно передать при вызове.
2. **Необязательные параметры (значения по умолчанию)** <br>
    Функции могут иметь параметры с значениями по умолчанию, которые можно не передавать. Если параметр не указан, будет использовано значение по умолчанию.

    Пример:
    ```python
    def greet(name="гость"):
    return f"Привет, {name}!"

    greet()        # Выведет: Привет, гость!
    greet("Анна")  # Выведет: Привет, Анна!
    ```
    Здесь `name` имеет значение по умолчанию "гость", которое используется, если аргумент не передан.

3. **Ключевые параметры** <br>
    При вызове функции можно передавать аргументы по имени параметра, а не по порядку. Это особенно полезно, когда есть много параметров, и порядок их не важен.

    Пример:
    ```python
    def introduce(name, age):
    return f"Меня зовут {name}, мне {age} лет."

    introduce(age=30, name="Иван")  # Выведет: Меня зовут Иван, мне 30 лет.
    ```
    Здесь `age=30` и `name="Иван"` передаются по имени параметра, и порядок вызова не важен.

4. **Аргументы произвольной длины** <br>
    Функции могут принимать произвольное количество аргументов:

    - `*args` — позволяет передать любое количество позиционных аргументов (аргументы без имени).

        Пример:

        ```python
        def sum_all(*args):
            return sum(args)

        sum_all(1, 2, 3, 4)  # Выведет: 10
        ```
        Здесь `*args` собирает все переданные значения (1, 2, 3, 4) в один кортеж `(1, 2, 3, 4)` и передает их в функцию.

    - `**kwargs` — позволяет передать любое количество именованных аргументов (аргументы с именами).

        Пример:
        ```python
        def print_kwargs(**kwargs):
            for key, value in kwargs.items():
                print(f"{key} = {value}")

        print_kwargs(name="Анна", age=30)
        # Выведет:
        # name = Анна
        # age = 30
        ```
        Здесь `**kwargs` собирает все именованные аргументы в словарь `{"name": "Анна", "age": 30}`.

**Пример функции со всеми типами параметров**

Функция может использовать разные типы параметров вместе:
```python
def example(a, b=2, *args, **kwargs):
    print(f"a: {a}, b: {b}")
    print(f"args: {args}")
    print(f"kwargs: {kwargs}")

example(1, 3, 4, 5, name="Python", version=3.9)
# Выведет:
# a: 1, b: 3
# args: (4, 5)
# kwargs: {'name': 'Python', 'version': 3.9}
```

- `a` — обязательный параметр.
- `b=2` — необязательный параметр со значением по умолчанию 2.
- `*args` — собирает все переданные дополнительные позиционные аргументы в кортеж `(4, 5)`.
- `**kwargs` — собирает все переданные именованные аргументы в словарь `{'name': 'Python', 'version': 3.9}`.

## Функция `lambda`

`lambda` — это анонимная (безымянная) функция в Python, которая создается с помощью ключевого слова `lambda`. Эти функции используются для создания небольших и простых функций "на месте", когда вам не нужно давать им имя и не требуется использовать их многократно.

**Зачем нужна `lambda`?**

Lambda-функции часто используются там, где требуется передать небольшую функцию как аргумент другой функции (например, для сортировки, фильтрации данных и т.д.). Это может упростить код и сделать его более компактным.

**Основные особенности `lambda`:**

- Это **анонимная** функция, то есть она не требует имени.
- Функция может содержать **любое количество аргументов**, но только **одно выражение**, результат которого возвращается.
- Lambda-функции являются **однострочными**, и в них нельзя писать многострочные выражения или блоки кода (например, циклы).

**Синтаксис `lambda`**

```python
lambda аргументы: выражение
```
Пример использования:
```python
# Обычная функция:
def add(x, y):
    return x + y

# Эквивалентная lambda-функция:
add_lambda = lambda x, y: x + y

print(add_lambda(2, 3))  # Выведет: 5
```

Здесь `lambda x, y: x + y` создает анонимную функцию, которая принимает два аргумента и возвращает их сумму.

Lambda-функции часто используются для сортировки:
```python
# Сортировка списка кортежей по второму элементу
pairs = [(1, 'one'), (2, 'two'), (3, 'three')]
sorted_pairs = sorted(pairs, key=lambda pair: pair[1])

print(sorted_pairs)
# Выведет: [(1, 'one'), (3, 'three'), (2, 'two')]
```

Пример с функцией `filter`:
```python
# Отбор четных чисел из списка
numbers = [1, 2, 3, 4, 5, 6]
even_numbers = list(filter(lambda x: x % 2 == 0, numbers))

print(even_numbers)  # Выведет: [2, 4, 6]
```

*Lambda-функции могут принимать любой тип данных в качестве параметров, включая:*

- числа (`int`, `float`)
- строки (`str`)
- списки (`list`)
- кортежи (`tuple`)
- словари (`dict`)
- множества (`set`)
- объекты пользовательских классов.

**Важные ограничения и особенности:**

- Lambda-функции ограничены в использовании сложных конструкций. Они могут содержать только одно выражение.

    Пример:
    ```python
    lambda x: x**2 + 1  # Работает
    ```
    Но нельзя использовать блоки кода, например `if` без выражений:
    ```python
    # Неверно:
    lambda x: if x > 10: x + 1  # Ошибка синтаксиса
    ```
- Lambda-функции не могут содержать присвоение значений переменным. В них допустимы только выражения.

- Lambda-функции могут принимать любое количество аргументов, но не могут иметь такие параметры, как `*args` или `**kwargs`.

- Важные ограничения имен:

    Lambda-функции не могут иметь имен — это и есть суть анонимности. Однако, если вам нужно использовать такую функцию повторно, вы можете присвоить ее переменной, как в примере выше (`add_lambda`).

**Пример более сложной lambda-функции**

```python
# Фильтрация чисел больше 5 и удвоение их значений
numbers = [1, 2, 3, 6, 7, 8]
result = list(map(lambda x: x * 2, filter(lambda x: x > 5, numbers)))

print(result)  # Выведет: [12, 14, 16]
```
Здесь мы сначала фильтруем числа больше 5, а затем удваиваем их значения.

**Lambda-функции полезны, когда:**

- Вам нужно определить небольшую функцию "на месте".
- Вы хотите сделать код компактнее.
- Вы передаете функцию как аргумент другой функции.

**Когда не стоит использовать lambda?**
- Когда функция содержит более одной логической операции — в этом случае лучше использовать обычную функцию с `def`.
- Если функция должна быть многоразовой и понятно задокументированной — лучше использовать именованную функцию.

# Работа с файлами в Python

## Работа с файлами: `open`, `close`, `write`, `read`

Для работы с файлами в Python используется функция `open()`. Файлы должны быть **закрыты** после использования для предотвращения утечек памяти. Для этого используется метод `close()`.

**Синтаксис:**
```python
file = open('путь_к_файлу', 'режим')
# Работа с файлом
file.close()
```

- `'путь_к_файлу'`: путь к файлу, который нужно открыть.
- `'режим'`: режим открытия файла, определяет, что будет делаться с файлом (чтение, запись и т.д.).

Режимы открытия файла:

Режим | Описание
------|----------
`'r'` | Открытие для чтения (по умолчанию). Если файл не существует, вызывает ошибку.
`'w'` | Открытие для записи. Создает файл, если его нет. Если файл существует — очищает его.
`'a'` | Открытие для добавления. Создает файл, если его нет. Данные записываются в конец файла.
`'x'` | Создание нового файла. Если файл уже существует, вызывает ошибку.
`'b'` | Бинарный режим. Например, `'rb'` для чтения в бинарном формате.
`'t'` | Текстовый режим (по умолчанию). Например, `'rt'` для чтения в текстовом формате.
`'+'` | Открытие для обновления (чтение и запись). Например, `'r+'` для чтения и записи.

Пример открытия файла для чтения:
```python
file = open('example.txt', 'r')  # Чтение файла
```
После работы с файлом его нужно закрыть с помощью метода `close()`:
```python
file.close()
```
Закрытие освобождает ресурсы, выделенные для файла. Если файл не закрыт, могут возникнуть проблемы с утечками памяти или неправильной записью данных.

**Запись в файл: `write()`**

Метод `write()` записывает данные в файл. Если файл был открыт в режиме записи или добавления, содержимое файла будет изменено. Метод не добавляет перевод строки автоматически, поэтому для новой строки нужно явно использовать символ \n.

```python
file = open('example.txt', 'w')
file.write('Первая строка.\n')
file.write('Вторая строка.')
file.close()
```

- Если файл не существует, он будет создан.
- Если файл открыт в режиме `'w'`, его содержимое будет перезаписано.

**Чтение из файла: `read()`**

Метод `read()` считывает содержимое файла целиком или частями.
```python
file = open('example.txt', 'r')
content = file.read()  # Считываем весь файл
print(content)
file.close()
```

**Чтение файла построчно через `for`:**

Часто удобно считывать файл построчно:
```python
file = open('example.txt', 'r')
for line in file:
    print(line.strip())  # Убираем символ перевода строки
file.close()
```

Методы для чтения:

- `read(size)`: Читает указанное количество символов или байт.
- `readline()`: Читает одну строку из файла.
- `readlines()`: Возвращает список строк.

```python
file = open('example.txt', 'r')
print(file.readline())  # Чтение первой строки
print(file.readlines())  # Чтение всех строк в список
file.close()
```

**Ошибки при открытии файлов**

Если файл не существует и его пытаются открыть в режиме чтения (`'r'`), Python выбросит ошибку `FileNotFoundError`:
```python
file = open('missing_file.txt', 'r')  # Ошибка: файл не найден
```

Если файл существует, но пытаются открыть его в режиме создания (`'x'`), Python вызовет `FileExistsError`.

**Запись и чтение бинарных файлов**

Для работы с бинарными файлами, например, изображениями, используйте режимы `'rb'` и `'wb'`.
```python
file = open('image.png', 'rb')  # Открытие изображения для чтения в бинарном формате
data = file.read()
file.close()

# Запись бинарных данных в новый файл
file = open('copy.png', 'wb')
file.write(data)
file.close()
```

**Чтение с использованием цикла `for`**<br>
Часто используется для поочередного чтения строк файла:
```python
file = open('example.txt', 'r')
for line in file:
    print(line, end='')  # end='' чтобы не добавлять лишний перевод строки
file.close()
```
Для работы с файлами, находящимися в другом каталоге, нужно указать полный путь к файлу:
```python
file = open('C:/path/to/file.txt', 'r')
```
## Обработчик исключений `try` - `except`

Python поддерживает систему обработки ошибок с помощью конструкций `try`, `except`, `else` и `finally`, позволяя управлять возникающими исключениями в программе.

Конструкция `try-except` позволяет "поймать" ошибки (исключения), которые возникают в блоке `try`, и обработать их в блоке `except`.

```python
try:
    # Код, в котором может возникнуть ошибка
except <Тип ошибки> as <имя_переменной>:
    # Код обработки исключения
```
Пример:
```python
try:
    x = 1 / 0  # Ошибка деления на ноль
except ZeroDivisionError as e:
    print(f"Произошла ошибка: {e}")
```

Можно обработать несколько разных типов ошибок с помощью нескольких блоков `except`:
```python
try:
    num = int(input("Введите число: "))
    result = 10 / num
except ValueError:
    print("Это не число!")
except ZeroDivisionError:
    print("Деление на ноль невозможно!")
```

Блок `else` выполняется, если в блоке `try` не возникло исключений:
```python
try:
    num = int(input("Введите число: "))
    result = 10 / num
except ZeroDivisionError:
    print("Ошибка деления на ноль.")
else:
    print(f"Результат: {result}")
```

Блок `finally` всегда выполняется, независимо от того, возникло исключение или нет. Он используется для освобождения ресурсов, таких как закрытие файлов:
```python
try:
    file = open('example.txt', 'r')
    content = file.read()
except FileNotFoundError:
    print("Файл не найден.")
finally:
    file.close()
    print("Файл закрыт.")
```

**Виды ошибок и исключений (built-in exceptions)**

Исключение | Описание
-----------|----------
`SyntaxError` | 	Ошибка синтаксиса. Возникает, если код не соответствует правилам языка Python.
`TypeError` | Возникает, когда операция или функция применяются к объекту неподходящего типа.
`ValueError` | Возникает, если функция получает аргумент правильного типа, но неподходящего значения.
`ZeroDivisionError` | Возникает при делении на ноль.
`FileNotFoundError` | Файл не найден. Возникает при попытке открыть несуществующий файл.
`KeyError` | Ошибка при попытке доступа к несуществующему ключу в словаре.
`IndexError` | Возникает при попытке доступа к элементу списка по несуществующему индексу.
`AttributeError` | Возникает, если объект не имеет требуемого атрибута.
`NameError` | Возникает, если переменная или функция не определены.
`IOError` | Ошибка ввода/вывода (например, при проблемах с файловой системой).
`ImportError` | Ошибка импорта модуля.
`RecursionError` | Возникает при превышении максимальной глубины рекурсии.

**Модуль `traceback`**

Модуль `traceback` используется для получения трассировки стека при возникновении исключений. Это позволяет увидеть последовательность вызовов функций, которые привели к исключению.
```python
import traceback

try:
    1 / 0
except ZeroDivisionError:
    print("Произошла ошибка деления на ноль.")
    traceback.print_exc()  # Печатает полную трассировку ошибки
```

Как работает трассировка (`traceback`):

- `Traceback` — это последовательность вызовов, ведущих к ошибке.
- Помогает разработчикам понять, на каком этапе возникла проблема и какой код к ней привел.

**Виды ошибок:**

1. `SyntaxError`

    Возникает, если код содержит синтаксическую ошибку:

    ```python
    print("Hello  # Пропущена закрывающая кавычка
    # SyntaxError: EOL while scanning string literal
    ```

2. `RuntimeError`

    Возникает во время выполнения программы, когда возникает ошибка, не связанная с синтаксисом.

3. `TypeError`

    Возникает при использовании неподходящего типа данных:

```python
x = "строка" + 5  # TypeError: can only concatenate str (not "int") to str
```

- `ValueError`

    Возникает, когда функция получает аргумент правильного типа, но с неправильным значением:

```python
int("abc")  # ValueError: invalid literal for int() with base 10: 'abc'
```

- `ZeroDivisionError`

    Возникает при попытке деления на ноль:

    ```python
    1 / 0  # ZeroDivisionError: division by zero
    ```
- `FileNotFoundError`

    Возникает, если файл не найден при попытке его открыть:

    ```python
    file = open('non_existent_file.txt', 'r')  # FileNotFoundError: [Errno 2] No such file or dire
    ```
**Дополнительные операторы в блоках исключений:**

Оператор `raise` используется для явного вызова исключения. Можно использовать, чтобы вызвать ошибку вручную.

```python
def divide(a, b):
    if b == 0:
        raise ZeroDivisionError("Деление на ноль невозможно!")
    return a / b

try:
    result = divide(10, 0)
except ZeroDivisionError as e:
    print(f"Ошибка: {e}")
```

Оператор `assert` используется для отладки, проверяя, истинно ли условие. Если условие ложно, выбрасывается исключение AssertionError.

```python
def calculate_price(amount):
    assert amount > 0, "Сумма должна быть положительной!"
    return amount * 100

try:
    price = calculate_price(-1)
except AssertionError as e:
    print(f"Ошибка: {e}")
```

## Конструкция `with` ... `as`

Конструкция `with ... as` в Python используется для автоматического управления ресурсами. Она гарантирует, что любые необходимые действия, такие как **закрытие файла** или **освобождение ресурсов**, будут выполнены автоматически после завершения блока кода, даже если возникнет ошибка. Это делает код более безопасным и понятным, особенно при работе с файлами.

```python
with expression [as target]:
    блок кода
```
- `expression` — объект, который управляет ресурсом, например, результат вызова функции `open()`.
- `target` — переменная, с которой будет связан объект (например, объект файла).
- `блок кода` — код, который выполняется в контексте открытого файла или другого ресурса.

Пример использования с файлами:
```python
with open('example.txt', 'r') as file:
    content = file.read()
    print(content)
# После завершения блока `with`, файл автоматически закрывается
```

**Преимущества использования `with ... as` для работы с файлами:**

- **Автоматическое закрытие файла:** Файл закрывается автоматически при завершении блока кода, даже если возникает ошибка.
- **Чистота кода:** Нет необходимости явно вызывать `file.close()`.
- **Безопасность:** Снижается вероятность ошибок при управлении ресурсами.

Как работает `with`?

Когда Python входит в блок `with`, он вызывает метод `__enter__()` у объекта, который возвращается выражением `with`. По завершении блока вызывается метод `__exit__()` этого объекта, который закрывает ресурс (например, файл). Это обеспечивает гарантированное освобождение ресурсов.

Пример чтения файла построчно:
```python
with open('example.txt', 'r') as file:
    for line in file:
        print(line.strip())  # .strip() убирает символы перевода строки
```

Также можно использовать `with` для работы с несколькими файлами одновременно:
```python
with open('file1.txt', 'r') as file1, open('file2.txt', 'w') as file2:
    content = file1.read()
    file2.write(content)
# Оба файла будут автоматически закрыты по завершении блока
```

`with` используется не только для работы с файлами, но и для управления любыми ресурсами, требующими открытия и последующего закрытия, например, сетевыми соединениями, блокировками потоков, базами данных и т.д.

Пример работы с блокировкой (например, для многопоточной программы):
```python
from threading import Lock

lock = Lock()

with lock:
    # критическая секция кода, выполняется в блоке с блокировкой
    print("Выполняется с блокировкой")
# После выхода из блока `with`, блокировка будет автоматически снята
```

Конструкция `with ... as` работает благодаря методам `__enter__()` и `__exit__()`, которые реализуют классы, поддерживающие протокол контекстного менеджера. Эти методы гарантируют, что объект, связанный с ресурсом, будет корректно обработан в начале и в конце использования.

Можно создать своего контекстного менеджера, реализовав методы __enter__() и __exit__() в классе:
```python
class FileManager:
    def __init__(self, filename, mode):
        self.filename = filename
        self.mode = mode

    def __enter__(self):
        self.file = open(self.filename, self.mode)
        return self.file

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.file.close()

# Использование собственного контекстного менеджера
with FileManager('example.txt', 'r') as f:
    content = f.read()
    print(content)
```

# Модули в языке Python

**Модуль** — это файл, содержащий Python-код: переменные, функции и классы. Модули позволяют структурировать код и повторно его использовать. Модули можно импортировать и использовать в других файлах или проектах.

**Синтаксис импорта**
- **Импорт всего модуля**: `import module_name`
- **Импорт с псевдонимом**: `import module_name as alias`
- **Импорт отдельных функций или классов**: `from module_name import func1, func2`
- **Импорт с псевдонимом для функций/классов**: `from module_name import func as alias`

В Python более 200 стандартных модулей. Основные включают:

| Модуль       | Описание                                         |
|--------------|--------------------------------------------------|
| `time`       | Работа с временем и задержками                   |
| `datetime`   | Работа с датой и временем                        |
| `sys`        | Взаимодействие с интерпретатором Python          |
| `os`         | Работа с операционной системой                   |
| `platform`   | Информация о платформе (ОС, версии и т.д.)       |
| `random`     | Генерация случайных чисел                        |
| `array`      | Массивы и операции над ними                      |
| `math`       | Математические функции                           |
| `cmath`      | Математика комплексных чисел                     |


Примеры использования:

```python
# Импорт модуля math с псевдонимом
import math as m
print(m.sqrt(25))  # Вывод: 5.0

# Импорт нескольких функций из модуля random
from random import randint, choice
print(randint(1, 10))  # Случайное число от 1 до 10
print(choice(['apple', 'banana', 'cherry']))  # Случайный выбор из списка
```

Модуль `time`

Обеспечивает функции для работы с временными интервалами и задержками.
```python
import time

time.sleep(1)  # Задержка на 1 секунду
print(time.time())  # Текущее время в секундах с начала эпохи
```

Модуль `datetime`

Позволяет работать с датой и временем, предоставляет классы `date`, `time`, `datetime`.

```python
from datetime import datetime

now = datetime.now()
print(now.strftime("%Y-%m-%d %H:%M:%S"))  # Форматированная дата и время
```

Модуль `sys`

Позволяет взаимодействовать с интерпретатором и системой.
```python
import sys

print(sys.version)  # Версия Python
print(sys.platform)  # Платформа (например, 'win32', 'linux')
```

Модуль `os`

Взаимодействие с операционной системой, управление файлами и директориями.
```python
import os

print(os.getcwd())  # Текущая рабочая директория
os.mkdir("new_folder")  # Создание новой директории
```
Модуль `platform`

Позволяет узнать информацию об операционной системе и платформе.
```python
import platform

print(platform.system())  # Название ОС (Windows, Linux и т.д.)
print(platform.release())  # Версия ОС
```

Модуль `random`

Работа с генерацией случайных чисел.
```python
import random

print(random.randint(1, 10))  # Случайное число от 1 до 10
print(random.choice(['apple', 'banana', 'cherry']))  # Случайный элемент списка
```

Модуль `array`

Работа с массивами, позволяет создавать массивы с фиксированными типами элементов.
```python
from array import array

arr = array('i', [1, 2, 3, 4])  # Массив целых чисел
print(arr)
```

Модуль `math`

Обеспечивает функции для математических операций, таких как `sqrt`, `sin`, `cos`.
```python
import math

print(math.pi)  # Число Пи
print(math.sqrt(16))  # Квадратный корень из 16
```
Модуль `cmath`

Поддержка операций с комплексными числами.
```python
import cmath

z = complex(1, 2)
print(cmath.phase(z))  # Аргумент комплексного числа
```

**Создание собственных модулей**

Чтобы создать собственный модуль, необходимо создать .py файл с функциями, классами или переменными.

Пример: создаем `my_module.py`:
```python
# my_module.py

def greet(name):
    return f"Hello, {name}!"
```

Теперь модуль `my_module` можно импортировать и использовать:
```python
from my_module import greet

print(greet("Alice"))  # Вывод: Hello, Alice!
```

**Использование библиотек**

Библиотека — это набор модулей, объединённых по функциональности. Например, `NumPy` — это библиотека для научных вычислений.

Для чего нужны библиотеки? Библиотеки содержат уже готовые функции и классы для выполнения общих задач, что экономит время разработки.
Менеджер пакетов `https://pypi.org/` — это репозиторий Python-пакетов. Установить пакет можно через pip:
```bash
pip install имя_библиотеки
```

Пример использования библиотеки `NumPy`:
```python
import numpy as np

array = np.array([1, 2, 3])
print(array.mean())  # Среднее значение массива
```
# Основы ООП

**Объектно-ориентированное программирование (ООП)** — это парадигма, в которой данные и методы для работы с ними объединены в единые структуры, называемые **объектами**. ООП позволяет создавать **модели** для реальных сущностей с помощью **классов**.


## Классы и объекты

- **Класс** — это шаблон, описывающий структуру и поведение объектов, которые будут созданы на его основе. Класс может содержать **поля** (свойства) и **методы** (действия), которые определяют, какими данными и поведением будут обладать объекты. В Python класс объявляется с помощью ключевого слова `class`.

- **Объект** — это экземпляр класса, имеющий определённые значения для каждого из полей, определённых в классе и может вызывать методы класса, чтобы выполнять определенные действия. Объекты создаются на основе класса и могут иметь уникальные данные.

- **Поле (атрибут)** — переменная, которая хранит данные о состоянии объекта или класса. Поля могут быть **атрибутами класса** (общими для всех экземпляров) и **атрибутами экземпляра** (индивидуальными для каждого экземпляра).

- **Метод** — функция, определенная внутри класса, которая определяет поведение объектов этого класса. Методы могут использовать атрибуты объекта, модифицировать их и выполнять задачи, связанные с объектом.

В этом примере создан класс `Book`, который описывает книгу с полями, установленными по умолчанию в `None`. После создания объектов на его основе будут установлены значения для этих полей.

```python
class Book:
    # Поля класса
    title = None
    author = None
    year = None

    # Метод для вывода информации о книге
    def show_info(self):
        print(f"'{self.title}' by {self.author}, published in {self.year}")

# Создаем объекты класса Book
book1 = Book()
book2 = Book()

# Устанавливаем значения для полей экземпляров
book1.title = "1984"
book1.author = "George Orwell"
book1.year = 1949

book2.title = "To Kill a Mockingbird"
book2.author = "Harper Lee"
book2.year = 1960

# Выводим информацию о книгах
book1.show_info()  # Выведет: '1984' by George Orwell, published in 1949
book2.show_info()  # Выведет: 'To Kill a Mockingbird' by Harper Lee, published in 1960
```
Описание примера:

Класс `Book` — это шаблон, который описывает структуру и поведение для объектов, представляющих книги. В классе определены три поля: `title`, `author` и `year`, которые изначально равны `None`.
Метод `show_info` — метод класса, который форматирует и выводит информацию о книге на основе значений полей объекта.
Создание объектов — `book1` и `book2` являются объектами класса `Book`. Для каждого из них устанавливаются свои значения для полей, которые затем используются при вызове метода `show_info`.
Этот подход позволяет создавать множество объектов на основе класса `Book`, с разными значениями для их полей.

Вот модифицированный код, в котором ввод данных объекта происходит в одну строку с помощью метода:
```python
class Book:
    # Поля класса
    title = None
    author = None
    year = None

    # Метод для ввода информации о книге
    def set_info(self, title, author, year):
        self.title = title
        self.author = author
        self.year = year

    # Метод для вывода информации о книге
    def show_info(self):
        print(f"'{self.title}' by {self.author}, published in {self.year}")

# Создаем объекты класса Book
book1 = Book()
book2 = Book()

# Устанавливаем значения для полей экземпляров
book1.set_info("1984", "George Orwell", 1949)
book2.set_info("To Kill a Mockingbird", "Harper Lee", 1960)

# Выводим информацию о книгах
book1.show_info()  # Выведет: '1984' by George Orwell, published in 1949
book2.show_info()  # Выведет: 'To Kill a Mockingbird' by Harper Lee, published in 1960
```

Описание изменений:
Добавлен метод `set_info`, который принимает три аргумента (`title`, `author`, `year`) и устанавливает соответствующие значения для полей объекта.
Вызов метода `set_info` позволяет устанавливать данные книги в одну строку.

## Конструкторы, переопределение методов

- Конструктор — это специальный метод, который автоматически вызывается при создании нового объекта класса.
- В Python конструктор обозначается методом `__init__`.
- Основная задача конструктора — инициализировать объект, задав начальные значения полям.

Конструктор `__init__` определяется внутри класса и принимает как минимум один параметр: `self`, который указывает на текущий экземпляр класса.

```python
class Example:
    def __init__(self, параметр1, параметр2):
        self.параметр1 = параметр1
        self.параметр2 = параметр2
```

Пример конструктора
```python
class Book:
    def __init__(self, title, author, year):
        self.title = title
        self.author = author
        self.year = year

    def show_info(self):
        print(f"'{self.title}' by {self.author}, published in {self.year}")

# Создание объекта с передачей параметров в конструктор
book = Book("1984", "George Orwell", 1949)
book.show_info()  # Выведет: '1984' by George Orwell, published in 1949
```

**Особенности конструктора**
- Параметры конструктора позволяют сразу задать начальные значения полям объекта.
- Конструктор может иметь значения по умолчанию для параметров:
```python
def __init__(self, title="Unknown", author="Unknown", year=0):
    self.title = title
    self.author = author
    self.year = year
```

**Что такое переопределение**

Переопределение методов позволяет изменять поведение унаследованных методов в дочерних классах.

В дочернем классе можно создать метод с таким же именем, как и в родительском, чтобы изменить его поведение.

В данном примере метод `show_info` из класса `Book` переопределяется в дочернем классе `EBook` для изменения вывода информаци
```python
class Book:
    def __init__(self, title, author):
        self.title = title
        self.author = author

    def show_info(self):
        print(f"'{self.title}' by {self.author}")

class EBook(Book):
    def __init__(self, title, author, file_size):
        super().__init__(title, author)  # Вызов конструктора родительского класса
        self.file_size = file_size

    # Переопределение метода show_info
    def show_info(self):
        print(f"'{self.title}' by {self.author} - {self.file_size}MB")

# Создание объекта класса EBook
ebook = EBook("1984", "George Orwell", 1.5)
ebook.show_info()  # Выведет: '1984' by George Orwell - 1.5MB
```

**Использование `super()`**

- `super()` позволяет вызвать методы и конструкторы родительского класса.
- В примере выше `super().__init__(title, author)` вызывает конструктор класса `Book`, чтобы установить `title` и `author`.

Резюмируя, конструкторы нужны для начальной настройки объектов, устанавливая начальные значения их атрибутов.
Переопределение методов используется для изменения поведения методов родительских классов в дочерних.

## Наследование, полиморфизм, инкапсуляция

**Наследование** — это механизм ООП, позволяющий одному классу (дочернему) получить свойства и методы другого класса (родительского).

Оно позволяет создать новый класс на основе существующего, расширяя или изменяя его функционал.

```python
class ParentClass:
    # Поля и методы родительского класса
    pass

class ChildClass(ParentClass):
    # Дополнительные поля и методы дочернего класса
    pass
```

Пример наследования
```python
class Animal:
    def speak(self):
        print("Animal speaks")

class Dog(Animal):
    def bark(self):
        print("Dog barks")

dog = Dog()
dog.speak()  # Наследованный метод: Animal speaks
dog.bark()   # Собственный метод: Dog barks
```

Особенности наследования
- Дочерний класс может использовать методы и поля родительского класса.
- Дочерний класс может переопределить методы родительского класса для изменения их поведения.

**Полиморфизм** — это когда один интерфейс (метод или функция) может работать с разными типами объектов, предоставляя общее поведение для них. Например, у объектов разных классов может быть метод с одинаковым именем, но разным поведением в зависимости от класса.

Благодаря полиморфизму разные классы могут иметь методы с одинаковыми именами, но с разной реализацией.
```python
class Cat:
    def speak(self):
        print("Meow")

class Dog:
    def speak(self):
        print("Bark")

def animal_sound(animal):
    animal.speak()  # Вызывается метод speak, независимо от типа животного

cat = Cat()
dog = Dog()

animal_sound(cat)  # Meow
animal_sound(dog)  # Bark
```

Здесь `animal_sound` принимает любой объект, у которого есть метод `sound`. Python не заботится о типе объекта; он проверяет только, существует ли у объекта данный метод.

Полиморфизм часто используется при наследовании, когда в дочерних классах переопределяются методы базового класса, что позволяет их использовать по-разному.

```python
class Animal:
    def make_sound(self):
        raise NotImplementedError("Subclass must implement this method")

class Cat(Animal):
    def make_sound(self):
        return "Meow"

class Dog(Animal):
    def make_sound(self):
        return "Woof"

# Функция, которая вызывает метод make_sound, работает для всех подклассов Animal
def call_sound(animal: Animal):
    print(animal.make_sound())

# Применяем полиморфизм:
cat = Cat()
dog = Dog()

call_sound(cat)  # Выведет: Meow
call_sound(dog)  # Выведет: Woof
```

Здесь `call_sound` может работать с любым подклассом `Animal`, который реализует метод `make_sound`. Это позволяет вызывать метод с разной реализацией, соответствующей конкретному классу.


Часто полиморфизм используется в программах, где несколько классов могут обрабатывать различные состояния или задачи, но вызываются они единым образом. Представьте, что нужно обработать несколько типов файлов, каждый из которых загружается и обрабатывается по-разному, но для всех вызывается метод `process`.

```python
class PDFFile:
    def process(self):
        return "Processing PDF file"

class ImageFile:
    def process(self):
        return "Processing image file"

class TextFile:
    def process(self):
        return "Processing text file"

def process_file(file):
    print(file.process())

# Создание разных объектов
pdf = PDFFile()
image = ImageFile()
text = TextFile()

# Полиморфный вызов одного метода
process_file(pdf)    # Выведет: Processing PDF file
process_file(image)  # Выведет: Processing image file
process_file(text)   # Выведет: Processing text file
```

Здесь метод process вызывается для разных типов файлов, но каждый раз работает специфично для типа файла, что является примером практического полиморфизма.

При вызове метода у объекта-наследника Python сначала ищет метод в самом классе-наследнике. Если он найден, Python выполнит его вместо метода из базового класса. Если такого метода нет, тогда он обратится к базовому классу.

Если нужно не просто заменить метод базового класса, а дополнить его, используется функция `super()`. Она вызывает метод базового класса из наследника.

```python
class Animal:
    def make_sound(self):
        return "Some generic sound"

class Dog(Animal):
    def make_sound(self):
        # Используем super() для вызова метода из базового класса
        base_sound = super().make_sound()
        return f"{base_sound} and Bark!"

# Создаем объект
dog = Dog()
print(dog.make_sound())  # Выведет: Some generic sound and Bark!
```

Здесь `super().make_sound()` вызывает метод `make_sound` базового класса `Animal`, а затем добавляет к его результату новую строку, создавая комбинированный вывод.

**Когда использовать переопределение метода?**

Когда поведение в наследуемом классе должно отличаться. Например, если у разных животных уникальные звуки.
Для добавления новой функциональности к базовому методу — в этом случае `super()` позволяет сначала выполнить родительский метод, а затем добавить специфичное для подкласса поведение.


Полиморфизм позволяет писать универсальный код, который может работать с различными типами объектов.

Это делает код более гибким и расширяемым — новые классы могут быть добавлены без изменения логики основного кода.

В Python, благодаря динамической типизации, можно применять полиморфизм к объектам, у которых нет общего класса-предка, но есть одинаковые методы (как в примере с `PDFFile`, `ImageFile`, `TextFile`).

**Инкапсуляция** — это механизм ограничения доступа к данным и методам внутри объекта, чтобы предотвратить несанкционированное вмешательство.

В Python доступ к атрибутам можно ограничить, добавив символы подчеркивания (`_` или `__`):
- Одно подчеркивание `_` перед именем атрибута делает его защищённым (`protected`).
- Два подчеркивания `__` делают атрибут приватным (`private`).

```python
class Car:
    def __init__(self, make, model):
        self.make = make          # Публичное поле
        self._model = model       # Защищённое поле
        self.__year = 2020        # Приватное поле

    def display(self):
        print(f"{self.make} {self._model}, Year: {self.__year}")

car = Car("Toyota", "Corolla")
print(car.make)     # Toyota
print(car._model)   # Corolla (доступ есть, но не рекомендуется)
# print(car.__year)  # Ошибка: AttributeError
car.display()       # Toyota Corolla, Year: 2020
```

**Особенности инкапсуляции:**

- Публичные поля доступны везде.
- **Одинарное подчёркивание `_`**: Атрибуты или методы, начинающиеся с `_`, считаются защищёнными (`protected`) по соглашению. Это указывает другим разработчикам, что они предназначены для внутреннего использования и не должны использоваться извне. Однако Python не запрещает доступ к ним.

    ```python
    class Example:
        def __init__(self):
            self._protected_var = "I'm protected, please respect my privacy!"

    obj = Example()
    print(obj._protected_var)  # Доступ разрешён, но не рекомендуется
    ```

- **Двойное подчёркивание `__`**: Атрибуты или методы, начинающиеся с `__`, считаются приватными (`private`). Python применяет маскировку имён (`name mangling`) к таким атрибутам, добавляя к ним имя класса. Это предотвращает случайный доступ к ним извне класса, но всё ещё не является абсолютным ограничением.

```python
class Example:
    def __init__(self):
        self.__private_var = "I'm private, more restricted than protected"

obj = Example()
# print(obj.__private_var)  # Ошибка: AttributeError
print(obj._Example__private_var)  # Обход ограничения с name mangling
```

Используя obj._Example__private_var, можно всё же получить доступ к приватному атрибуту.

- Философия Python: Python следует принципу "Мы все здесь взрослые люди" ("We are all consenting adults here"), что означает доверие к разработчику, чтобы он соблюдал соглашения и не злоупотреблял доступом к защищённым и приватным данным.

Python инкапсуляция считается более гибкой, чем жёсткой, и позволяет обращаться к атрибутам, которые технически должны быть защищёнными или приватными. Это удобно для тестирования и отладки, но требует от разработчиков соблюдения соглашений, чтобы не нарушать целостность данных.

**Другими словами:**

Инкапсуляция в Python основана на соглашениях, а не на строгих ограничениях. Приватные атрибуты можно обойти через `name mangling`, так что безопасность данных здесь относительно условна.

`Name mangling` (дословно «искажение имени») — это механизм Python, используемый для предотвращения случайного доступа к приватным атрибутам и методам класса. Когда атрибут или метод начинается с двойного подчёркивания (`__`) и не заканчивается им, Python автоматически преобразует его имя, добавляя перед ним имя класса. Это помогает избежать конфликтов в именах при наследовании и намекает на то, что атрибут не предназначен для внешнего использования.

Когда вы объявляете атрибут с двумя подчёркиваниями, например, `__attribute`, Python преобразует его имя, добавляя перед ним `_ClassName`. Таким образом, `__attribute` в классе `Example` станет `_Example__attribute`.
```python
class Example:
    def __init__(self):
        self.__private_var = "I'm private"

    def get_private_var(self):
        return self.__private_var  # доступ к приватной переменной внутри класса

obj = Example()

# Попытка прямого доступа вызывает ошибку
# print(obj.__private_var)  # Ошибка: AttributeError

# Правильный способ — доступ к приватной переменной через метод класса
print(obj.get_private_var())  # Вывод: I'm private

# Обход name mangling, доступ возможен так:
print(obj._Example__private_var)  # Вывод: I'm private
```

Особенности `name mangling`:

- `Зачем нужен:` `Name mangling` помогает разработчикам создавать приватные атрибуты, чтобы случайно не переопределить их в дочерних классах или других частях кода.
- `Когда применяется:` Только для атрибутов и методов с начальным `__`, но без завершающего подчёркивания. Например, `__attribute` преобразуется, а `_attribute` и `__attribute__` остаются как есть.
- Не является строгой защитой: Хотя `name mangling` затрудняет доступ, это не блокировка. Доступ к этим атрибутам возможен при необходимости, хотя и нежелательно.

## Декораторы

Декораторы в Python — это специальный инструмент, который позволяет изменить или дополнить поведение функций, методов и классов. Декораторы помогают сделать код более компактным, гибким и организованным.

**Декоратор** — это функция, которая принимает другую функцию как аргумент и возвращает новую функцию с изменённым или дополненным поведением.
Декораторы позволяют переиспользовать код и добавлять функциональность к функциям, методам и классам без изменения их исходного кода.

Декораторы обозначаются знаком `@` перед названием функции-декоратора и указываются перед функцией, которую нужно изменить.

```python
@decorator_function
def my_function():
    pass
```
Этот код эквивалентен следующему:
```python
def my_function():
    pass

my_function = decorator_function(my_function)
```

Пример декоратора, который выводит сообщение до и после выполнения функции:
```python
def my_decorator(func):
    def wrapper():
        print("До вызова функции")
        func()
        print("После вызова функции")
    return wrapper

@my_decorator
def say_hello():
    print("Hello!")

say_hello()
# Вывод:
# До вызова функции
# Hello!
# После вызова функции
```

Чтобы создать декоратор для функции с аргументами, нужно передать `*args` и `**kwargs` в `wrapper`.
```python
def my_decorator(func):
    def wrapper(*args, **kwargs):
        print("До вызова функции")
        result = func(*args, **kwargs)
        print("После вызова функции")
        return result
    return wrapper

@my_decorator
def greet(name):
    print(f"Hello, {name}!")

greet("Alice")
# Вывод:
# До вызова функции
# Hello, Alice!
# После вызова функции
```

Если функция возвращает результат, декоратор должен вернуть это значение, чтобы его можно было использовать.

```python
def my_decorator(func):
    def wrapper(*args, **kwargs):
        print("Вызов функции")
        result = func(*args, **kwargs)
        print("Функция завершена")
        return result
    return wrapper

@my_decorator
def add(a, b):
    return a + b

print(add(3, 5))
# Вывод:
# Вызов функции
# Функция завершена
# 8
```

Иногда нужно создать декоратор, который принимает параметры. Для этого нужно добавить ещё одну обёртку.

```python
def repeat(num_times):  # Декоратор с параметром
    def decorator(func):
        def wrapper(*args, **kwargs):
            for _ in range(num_times):
                result = func(*args, **kwargs)
            return result
        return wrapper
    return decorator

@repeat(3)
def say_hi():
    print("Hi!")

say_hi()
# Вывод:
# Hi!
# Hi!
# Hi!
```

Чтобы сохранить имя, документацию и атрибуты оригинальной функции, используется декоратор `functools.wraps`.

```python
from functools import wraps

def my_decorator(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        print("Вызов декорированной функции")
        return func(*args, **kwargs)
    return wrapper

@my_decorator
def example():
    """Эта функция делает что-то полезное"""
    print("Пример работы")

print(example.__name__)  # Вывод: example
print(example.__doc__)   # Вывод: Эта функция делает что-то полезное
```

**Примеры полезных декораторов:**

Логирующий декоратор
```python
from functools import wraps

def log_function(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        print(f"Вызов функции {func.__name__} с аргументами {args} и {kwargs}")
        return func(*args, **kwargs)
    return wrapper

@log_function
def multiply(a, b):
    return a * b

print(multiply(3, 5))
# Вывод:
# Вызов функции multiply с аргументами (3, 5) и {}
# 15
```

Проверка прав доступа

```python
def require_admin(func):
    @wraps(func)
    def wrapper(user_role, *args, **kwargs):
        if user_role != "admin":
            print("Доступ запрещен")
            return None
        return func(*args, **kwargs)
    return wrapper

@require_admin
def delete_database():
    print("База данных удалена!")

delete_database("user")    # Вывод: Доступ запрещен
delete_database("admin")   # Вывод: База данных удалена!
```

Декораторы можно использовать и для методов классов. Например, декоратор `@classmethod` для методов, которые работают с классом, и `@staticmethod` для методов, которые не используют `self` или `cls`.

```python
class MyClass:
    @staticmethod
    def static_method():
        print("Это статический метод")

    @classmethod
    def class_method(cls):
        print(f"Это метод класса {cls}")

MyClass.static_method()  # Вывод: Это статический метод
MyClass.class_method()   # Вывод: Это метод класса <class '__main__.MyClass'>
```

Можно использовать несколько декораторов для одной функции, тогда они применяются сверху вниз. Такие декораторы называются вложенными.

```python
def decorator1(func):
    def wrapper(*args, **kwargs):
        print("Декоратор 1")
        return func(*args, **kwargs)
    return wrapper

def decorator2(func):
    def wrapper(*args, **kwargs):
        print("Декоратор 2")
        return func(*args, **kwargs)
    return wrapper

@decorator1
@decorator2
def greet():
    print("Hello!")

greet()
# Вывод:
# Декоратор 1
# Декоратор 2
# Hello!
```

Декораторы в стандартной библиотеке Python:

`@property`: для создания свойств в классах.
`@staticmethod` и `@classmethod`: для объявления статических методов и методов класса.
`@functools.lru_cache`: для кеширования результата функции (полезно для оптимизации часто вызываемых функций).

```python
from functools import lru_cache

@lru_cache(maxsize=100)
def fibonacci(n):
    if n < 2:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

print(fibonacci(50))  # Использует кеш для оптимизации
```